<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive RC/RL/RLC Circuit Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { 
            --bg-color: #020617; 
            --card-color: rgba(15, 23, 42, 0.7);
            --border-color: #1e293b; 
            --text-light: #e2e8f0;
            --accent-color: #38bdf8;
            --voltage-color: #f59e0b; /* Orange */
            --current-color: #10b981; /* Green */
            --inductor-current-color: #ec4899; /* Pink */
        }
        body { background-color: var(--bg-color); color: var(--text-light); font-family: 'Inter', sans-serif; }
        .glass-card { background: var(--card-color); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid var(--border-color); }
        input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: var(--border-color); border-radius: 99px; outline: none; transition: background-color 0.2s ease; }
        input[type=range]:hover { background: #334155; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            border-radius: 50%; background: var(--accent-color); border: 2px solid var(--text-light);
            cursor: pointer; transition: transform 0.1s ease-in-out, box-shadow 0.2s ease;
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.4); }
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2364748b' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em;
            padding-right: 2.5rem; -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">
    <div class="container mx-auto max-w-7xl">
        <header class="mb-6 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-sky-300 to-cyan-400">Interactive Circuit Simulator</h1>
            <p class="mt-2 text-slate-400 max-w-2xl mx-auto">Explore RC, RL, and RLC circuits by adjusting components and observing the real-time transient response.</p>
        </header>

        <div class="glass-card shadow-2xl p-2 rounded-2xl mb-6">
            <canvas id="simulation-canvas" class="w-full h-[550px] md:h-[600px] rounded-lg"></canvas>
        </div>
        
        <div>
            <h2 class="text-2xl font-bold text-center mb-4 text-slate-300">Control Deck</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Source & Components -->
                <div class="glass-card shadow-lg p-5 rounded-2xl space-y-4">
                    <h3 class="font-bold text-lg text-sky-300 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M14 9a2 2 0 0 1-2 2H6l-4 4V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v5Z"/><path d="M18 9h2a2 2 0 0 1 2 2v4l-4 4H8a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h2"/></svg>
                        Source & Components
                    </h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4 text-sm pt-2">
                         <div>
                            <label for="voltage" class="font-medium text-slate-300 flex justify-between">Voltage: <span id="v-val">10 V</span></label>
                            <input type="range" id="voltage" min="1" max="50" step="1" value="10">
                        </div>
                        <div>
                            <label for="circuit-type" class="font-medium text-slate-300">Circuit Type</label>
                            <select id="circuit-type" class="w-full mt-1 bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white">
                                <option value="RC">RC Circuit</option>
                                <option value="RL">RL Circuit</option>
                                <option value="RLC">RLC Series</option>
                            </select>
                        </div>
                        <div>
                            <label for="resistor" class="font-medium text-slate-300 flex justify-between">Resistance: <span id="r-val">100 Ω</span></label>
                            <input type="range" id="resistor" min="1" max="1000" step="1" value="100">
                        </div>
                        <div>
                            <label for="capacitor" class="font-medium text-slate-300 flex justify-between">Capacitance: <span id="c-val">100 µF</span></label>
                            <input type="range" id="capacitor" min="1" max="1000" step="1" value="100">
                        </div>
                        <div>
                            <label for="inductor" class="font-medium text-slate-300 flex justify-between">Inductance: <span id="l-val">20 mH</span></label>
                            <input type="range" id="inductor" min="1" max="100" step="1" value="20">
                        </div>
                    </div>
                </div>

                <!-- Analysis -->
                <div class="glass-card shadow-lg p-5 rounded-2xl space-y-4">
                     <h3 class="font-bold text-lg text-sky-300 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M3 3v18h18"/><path d="m19 9-5 5-4-4-3 3"/></svg>
                        Analysis
                    </h3>
                    <div class="text-sm pt-2 space-y-2">
                        <p class="flex justify-between text-slate-400">Time Constant (τ): <span id="tau-val" class="font-mono text-white">10.0 ms</span></p>
                        <p class="flex justify-between text-slate-400">Resonant Freq (ω₀): <span id="omega-val" class="font-mono text-white">N/A</span></p>
                        <p class="flex justify-between text-slate-400">Damping Factor (α): <span id="alpha-val" class="font-mono text-white">N/A</span></p>
                        <p class="flex justify-between text-slate-400">Damping Type: <span id="damp-val" class="font-mono text-white">N/A</span></p>
                         <div class="pt-4 text-xs">
                             <div id="legend-vc" class="flex items-center"><div class="w-3 h-3 rounded-full mr-2" style="background:var(--voltage-color)"></div>Vc (Capacitor Voltage)</div>
                             <div id="legend-is" class="flex items-center"><div class="w-3 h-3 rounded-full mr-2" style="background:var(--current-color)"></div>Is (Source/Inductor Current)</div>
                         </div>
                    </div>
                </div>
                
                <div class="glass-card shadow-lg p-5 rounded-2xl flex flex-col justify-center">
                    <p class="text-center text-sm text-slate-400 mb-4">Click the switch on the diagram to run the simulation.</p>
                     <button id="reset-btn" class="w-full bg-slate-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-slate-700 transition-colors flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M3 2v6h6"/><path d="M21 12A9 9 0 0 0 6 5.3L3 8"/><path d="M21 22v-6h-6"/><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"/></svg>
                        Reset Simulation
                    </button>
                </div>
            </div>
        </div>
    </div>

<script>
(function() {
    const canvas = document.getElementById('simulation-canvas');
    const ctx = canvas.getContext('2d');
    const inputs = {
        voltage: document.getElementById('voltage'), resistor: document.getElementById('resistor'),
        capacitor: document.getElementById('capacitor'), inductor: document.getElementById('inductor'),
        circuitType: document.getElementById('circuit-type'),
    };
    const valueSpans = {
        voltage: document.getElementById('v-val'), resistor: document.getElementById('r-val'),
        capacitor: document.getElementById('c-val'), inductor: document.getElementById('l-val'),
    };
    const metrics = {
        tau: document.getElementById('tau-val'), omega: document.getElementById('omega-val'),
        alpha: document.getElementById('alpha-val'), damping: document.getElementById('damp-val'),
    };
    const legend = {
        vc: document.getElementById('legend-vc'),
        is: document.getElementById('legend-is'),
    };
    const resetBtn = document.getElementById('reset-btn');

    let state = { V: 10, R: 100, C: 100e-6, L: 20e-3, type: 'RC' };
    let sim = { t: 0, I: 0, Vc: 0, dIdt: 0, running: false, switchClosed: false, history: [], particles: [] };
    let rafId = null;
    const DT = 0.0001; // Simulation time step (small for stability)
    const MAX_HISTORY = 500;
    
    // --- Drawing & Geometry ---
    let layout = {};

    function resizeCanvas() {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height > 100 ? rect.height : 600;
        
        const cW = canvas.width, cH = canvas.height;
        const circuitHeight = cH * 0.55;
        const graphHeight = cH * 0.3;
        
        layout = {
            circuit: { y0: 50, y1: circuitHeight, midY: circuitHeight / 2 + 30, x0: 50, x1: cW - 50 },
            graph: { x: 60, y: circuitHeight + 40, w: cW - 100, h: graphHeight },
            switch: { x: cW / 2 - 20, y: 50 }
        };
        draw();
    }
    
    // --- Simulation Core ---
    function resetSimulation() {
        sim.running = false;
        sim.switchClosed = false;
        sim.t = 0;
        sim.I = 0;
        sim.Vc = 0;
        sim.dIdt = 0;
        sim.history = [];
        sim.particles = [];
        if(rafId) cancelAnimationFrame(rafId);
        updateStateFromInputs();
        draw();
    }

    function updateStateFromInputs() {
        state.V = parseFloat(inputs.voltage.value);
        state.R = parseFloat(inputs.resistor.value);
        state.C = parseFloat(inputs.capacitor.value) * 1e-6; // µF to F
        state.L = parseFloat(inputs.inductor.value) * 1e-3; // mH to H
        state.type = inputs.circuitType.value;

        // Update UI Text
        valueSpans.voltage.textContent = `${state.V.toFixed(0)} V`;
        valueSpans.resistor.textContent = `${state.R.toFixed(0)} Ω`;
        valueSpans.capacitor.textContent = `${(state.C * 1e6).toFixed(0)} µF`;
        valueSpans.inductor.textContent = `${(state.L * 1e3).toFixed(0)} mH`;
        
        updateAnalysisMetrics();
        draw();
    }
    
    function updateAnalysisMetrics() {
        legend.vc.style.display = (state.type === 'RC' || state.type === 'RLC') ? 'flex' : 'none';
        
        if (state.type === 'RC') {
            const tau = state.R * state.C;
            metrics.tau.textContent = `${(tau * 1000).toFixed(1)} ms`;
            metrics.omega.textContent = metrics.alpha.textContent = metrics.damping.textContent = 'N/A';
        } else if (state.type === 'RL') {
            const tau = state.L / state.R;
            metrics.tau.textContent = `${(tau * 1000).toFixed(1)} ms`;
            metrics.omega.textContent = metrics.alpha.textContent = metrics.damping.textContent = 'N/A';
        } else if (state.type === 'RLC') {
            const alpha = state.R / (2 * state.L);
            const omega0 = 1 / Math.sqrt(state.L * state.C);
            metrics.tau.textContent = 'N/A';
            metrics.alpha.textContent = `${alpha.toFixed(1)}`;
            metrics.omega.textContent = `${omega0.toFixed(1)}`;
            if (alpha > omega0) metrics.damping.textContent = 'Overdamped';
            else if (Math.abs(alpha - omega0) < 1e-6) metrics.damping.textContent = 'Critically Damped';
            else metrics.damping.textContent = 'Underdamped';
        }
    }

    function physicsStep() {
        let dVcdt = 0;
        if (state.type === 'RC') {
            dVcdt = (state.V - sim.Vc) / (state.R * state.C);
            sim.Vc += dVcdt * DT;
            sim.I = (state.V - sim.Vc) / state.R;
        } else if (state.type === 'RL') {
            sim.dIdt = (state.V - sim.I * state.R) / state.L;
            sim.I += sim.dIdt * DT;
        } else if (state.type === 'RLC') {
            dVcdt = sim.I / state.C;
            sim.dIdt = (state.V - sim.I * state.R - sim.Vc) / state.L;
            sim.Vc += dVcdt * DT;
            sim.I += sim.dIdt * DT;
        }
        sim.t += DT;

        if (sim.t > 0.001) { // Throttle history push
            sim.history.push({ t: sim.t, Vc: sim.Vc, I: sim.I });
            if (sim.history.length > MAX_HISTORY) sim.history.shift();
        }
    }

    function loop() {
        if (!sim.running) return;
        for (let i = 0; i < 10; i++) physicsStep(); // 10 substeps for accuracy
        draw();
        rafId = requestAnimationFrame(loop);
    }
    
    // --- Drawing Functions ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCircuit();
        drawGraph();
    }

    function drawCircuit() {
        const { y0, y1, midY, x0, x1 } = layout.circuit;
        
        // Draw wires
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x0, midY); ctx.lineTo(x0, y0); ctx.lineTo(layout.switch.x, y0);
        ctx.moveTo(layout.switch.x + 40, y0); ctx.lineTo(x1, y0); ctx.lineTo(x1, midY);
        ctx.moveTo(x0, midY); ctx.lineTo(x0, y1); ctx.lineTo(x1, y1); ctx.lineTo(x1, midY);
        ctx.stroke();

        drawSymbol.voltage(x0, midY, 40);
        drawSymbol.switch(layout.switch.x, layout.switch.y);

        const componentX = x0 + (x1-x0)/2 - 20;
        if (state.type === 'RC') {
            drawSymbol.resistor(componentX, y0, 'R');
            drawSymbol.capacitor(componentX, y1, 'C');
        } else if (state.type === 'RL') {
            drawSymbol.resistor(componentX, y0, 'R');
            drawSymbol.inductor(componentX, y1, 'L');
        } else if (state.type === 'RLC') {
            drawSymbol.resistor(x0 + 100, y0, 'R');
            drawSymbol.inductor(x1 - 100, y0, 'L');
            drawSymbol.capacitor(componentX, y1, 'C');
        }
        if (sim.switchClosed) drawCurrent();
    }
    
    const drawSymbol = {
        voltage: (x, y, h) => {
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x, y - h/2); ctx.lineTo(x, y - 10); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x, y + 10); ctx.lineTo(x, y + h/2); ctx.stroke();
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(x - 15, y - 10); ctx.lineTo(x + 15, y - 10); ctx.stroke();
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(x - 8, y + 10); ctx.lineTo(x + 8, y + 10); ctx.stroke();
            ctx.font = '12px Inter'; ctx.fillStyle = '#e2e8f0'; ctx.fillText('Vs', x-35, y+5);
        },
        resistor: (x, y, label) => {
            const w = 60, h = 20;
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2;
            ctx.strokeRect(x - w/2, y - h/2, w, h);
            ctx.font = '12px Inter'; ctx.fillStyle = '#e2e8f0'; ctx.fillText(label, x-5, y+25);
        },
        capacitor: (x, y, label) => {
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x-15, y); ctx.lineTo(x+15, y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x-15, y - 20); ctx.lineTo(x-15, y + 20); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x+15, y - 20); ctx.lineTo(x+15, y + 20); ctx.stroke();
            ctx.font = '12px Inter'; ctx.fillStyle = '#e2e8f0'; ctx.fillText(label, x-5, y-25);
        },
        inductor: (x, y, label) => {
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x-30, y);
            ctx.arc(x-20, y, 10, Math.PI, 0, false);
            ctx.arc(x,    y, 10, Math.PI, 0, false);
            ctx.arc(x+20, y, 10, Math.PI, 0, false);
            ctx.lineTo(x+30, y);
            ctx.stroke();
            ctx.font = '12px Inter'; ctx.fillStyle = '#e2e8f0'; ctx.fillText(label, x-5, y+25);
        },
        switch: (x, y) => {
            ctx.fillStyle = '#e2e8f0';
            ctx.beginPath(); ctx.arc(x, y, 4, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(x+40, y, 4, 0, 2*Math.PI); ctx.fill();
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x+4, y);
            if (sim.switchClosed) { ctx.lineTo(x+40-4, y); } 
            else { ctx.lineTo(x+25, y-15); }
            ctx.stroke();
        }
    };
    
    function getCircuitPath() {
        const { y0, y1, midY, x0, x1 } = layout.circuit;
        const points = [
            { x: x0, y: midY }, { x: x0, y: y0 }, { x: layout.switch.x, y: y0 },
            { x: layout.switch.x + 40, y: y0 }, { x: x1, y: y0 }, { x: x1, y: midY },
            { x: x1, y: y1 }, { x: x0, y: y1 }, { x: x0, y: midY },
        ];

        const path = { points, segments: [], totalLength: 0 };
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i+1];
            const length = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            path.segments.push({ start: p1, end: p2, length, cumulative: path.totalLength });
            path.totalLength += length;
        }
        return path;
    }

    function drawCurrent() {
        if (!sim.running || !sim.switchClosed) {
            sim.particles = [];
            return;
        }
        const path = getCircuitPath();
        if (path.totalLength === 0) return;

        const speed = Math.abs(sim.I) * 150;
        const frameSpeed = speed * (DT * 10);

        for (let i = sim.particles.length - 1; i >= 0; i--) {
            sim.particles[i].dist += frameSpeed;
            if (sim.particles[i].dist > path.totalLength) {
                sim.particles.splice(i, 1);
            }
        }

        const particleDensity = 150;
        const lastParticle = sim.particles[sim.particles.length - 1];
        if (!lastParticle || lastParticle.dist > particleDensity) {
            if (sim.particles.length < 50) {
                 sim.particles.push({ dist: 0 });
            }
        }
        
        ctx.fillStyle = 'var(--accent-color)';
        ctx.globalAlpha = 0.8;
        for (const p of sim.particles) {
            for (const seg of path.segments) {
                if (p.dist >= seg.cumulative && p.dist < seg.cumulative + seg.length) {
                    const distIntoSegment = p.dist - seg.cumulative;
                    const ratio = distIntoSegment / seg.length;
                    const x = seg.start.x + (seg.end.x - seg.start.x) * ratio;
                    const y = seg.start.y + (seg.end.y - seg.start.y) * ratio;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                }
            }
        }
        ctx.globalAlpha = 1.0;
    }

    function drawGraph() {
        const g = layout.graph;
        ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
        ctx.strokeRect(g.x, g.y, g.w, g.h);
        
        if (sim.history.length < 2) return;
        
        let timeWindow = 0.05; // Default window
        if (state.type === 'RC') timeWindow = 5 * state.R * state.C;
        else if (state.type === 'RL') timeWindow = 5 * state.L / state.R;
        else if (state.type === 'RLC') {
            const alpha = state.R / (2 * state.L);
            timeWindow = alpha > 1 ? 5 / alpha : 0.1;
        }
        const tMax = Math.max(timeWindow, sim.history[sim.history.length - 1].t);
        
        const vMax = state.V * 1.2;
        const iMaxAbs = sim.history.reduce((max, p) => Math.max(max, Math.abs(p.I)), 0);
        const iMax = Math.max(state.V / state.R, iMaxAbs) * 1.2 || 1;

        function plot(key, color, isBipolar) {
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
            sim.history.forEach((p, i) => {
                const x = g.x + (p.t / tMax) * g.w;
                let y;
                if (isBipolar) {
                    y = g.y + g.h / 2 - (p[key] / iMax) * (g.h / 2);
                } else {
                    const maxVal = key.startsWith('V') ? vMax : iMax;
                    y = g.y + g.h - (p[key] / maxVal) * g.h;
                }
                if (x > g.x + g.w) return;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }
        
        if (state.type === 'RC' || state.type === 'RLC') {
            plot('Vc', 'var(--voltage-color)', false);
        }
        plot('I', 'var(--current-color)', state.type === 'RLC');
    }

    // --- Event Handlers ---
    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        if (x > layout.switch.x && x < layout.switch.x + 40 && y > layout.switch.y - 20 && y < layout.switch.y + 20) {
            sim.switchClosed = !sim.switchClosed;
            if (sim.switchClosed) {
                if(!sim.running) { // Prevent reset on pause/resume
                    resetSimulation();
                    sim.switchClosed = true;
                }
                sim.running = true;
                loop();
            } else {
                sim.running = false;
            }
        }
    });

    resetBtn.addEventListener('click', resetSimulation);
    Object.values(inputs).forEach(input => input.addEventListener('input', updateStateFromInputs));
    window.addEventListener('resize', resizeCanvas);
    
    resetSimulation();
})();
</script>
</body>
</html>

