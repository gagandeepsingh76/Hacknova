<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Optics & Ray Tracing Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { 
            --bg-color: #020617; 
            --card-color: rgba(15, 23, 42, 0.7);
            --border-color: #1e293b; 
            --text-color: #94a3b8;
            --text-light: #e2e8f0;
            --accent-color: #38bdf8;
            --accent-hover: #0ea5e9;
            --accent-secondary: #f472b6;
            --ray-parallel: #f59e0b; /* Orange */
            --ray-focal: #10b981;    /* Green */
            --ray-central: #ec4899;  /* Pink */
        }
        body { 
            background-color: var(--bg-color); 
            color: var(--text-light); 
            font-family: 'Inter', sans-serif;
        }
        .glass-card { 
            background: var(--card-color); 
            backdrop-filter: blur(16px); 
            -webkit-backdrop-filter: blur(16px); 
            border: 1px solid var(--border-color); 
        }
        input[type=range] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 6px;
            background: var(--border-color);
            border-radius: 99px; outline: none;
            transition: background-color 0.2s ease;
        }
        input[type=range]:hover { background: #334155; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px;
            border-radius: 50%; background: var(--accent-color);
            border: 2px solid var(--text-light); cursor: pointer;
            transition: transform 0.1s ease-in-out, box-shadow 0.2s ease;
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
        }
        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.4);
        }
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2364748b' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        canvas { touch-action: none; cursor: grab; }
        canvas:active { cursor: grabbing; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">
    <div class="container mx-auto max-w-7xl">
        <header class="mb-6 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-sky-300 to-cyan-400">Interactive Optics Simulator</h1>
            <p class="mt-2 text-slate-400 max-w-2xl mx-auto">Explore thin lens physics by dragging the object and adjusting lens properties in real-time.</p>
        </header>

        <!-- SIMULATION CANVAS AREA -->
        <div class="glass-card shadow-2xl p-2 rounded-2xl mb-6">
            <canvas id="optics-canvas" class="w-full h-72 md:h-[500px] rounded-lg"></canvas>
        </div>
        
        <!-- CONTROL DECK -->
        <div>
            <h2 class="text-2xl font-bold text-center mb-4 text-slate-300">Control Deck</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Object & Lens Controls -->
                <div class="glass-card shadow-lg p-5 rounded-2xl space-y-4">
                    <h3 class="font-bold text-lg text-sky-300 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>
                        Object & Lens Controls
                    </h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-6 text-sm pt-2">
                        <div>
                            <label for="object-pos" class="font-medium text-slate-300 flex justify-between">Object Distance: <span id="obj-val">30 cm</span></label>
                            <input type="range" id="object-pos" min="1" max="150" value="30" step="1">
                        </div>
                        <div>
                            <label for="object-height" class="font-medium text-slate-300 flex justify-between">Object Height: <span id="obj-h-val">10 cm</span></label>
                            <input type="range" id="object-height" min="1" max="50" value="10" step="1">
                        </div>
                        <div>
                            <label for="focal-length" class="font-medium text-slate-300 flex justify-between">Focal Length: <span id="f-val">20 cm</span></label>
                            <input type="range" id="focal-length" min="5" max="80" value="20" step="1">
                        </div>
                        <div>
                            <label for="lens-type" class="font-medium text-slate-300">Lens Type</label>
                            <select id="lens-type" class="w-full mt-1 bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-sky-500 focus:border-sky-500">
                                <option value="converging">Converging (Convex)</option>
                                <option value="diverging">Diverging (Concave)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Image Properties -->
                <div class="glass-card shadow-lg p-5 rounded-2xl">
                    <h3 class="font-bold text-lg text-sky-300 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z" /><path d="m9 12 2 2 4-4" /></svg>
                        Image Properties
                    </h3>
                    <div class="grid grid-cols-2 gap-x-6 gap-y-3 text-sm pt-4">
                        <p class="text-slate-400">Image Distance:</p>
                        <p id="img-val" class="font-semibold font-mono text-white text-right">60.0 cm</p>
                        <p class="text-slate-400">Magnification:</p>
                        <p id="mag-val" class="font-semibold font-mono text-white text-right">-2.00</p>
                        <p class="text-slate-400">Image Type:</p>
                        <p id="type-val" class="font-semibold text-white text-right">Real, Inverted</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
(function() {
    const canvas = document.getElementById('optics-canvas');
    const ctx = canvas.getContext('2d');
    const inputs = {
        objectPos: document.getElementById('object-pos'),
        objectHeight: document.getElementById('object-height'),
        focalLength: document.getElementById('focal-length'),
        lensType: document.getElementById('lens-type'),
    };
    const valueSpans = {
        objectPos: document.getElementById('obj-val'),
        objectHeight: document.getElementById('obj-h-val'),
        focalLength: document.getElementById('f-val'),
    };
    const metrics = {
        imagePos: document.getElementById('img-val'),
        magnification: document.getElementById('mag-val'),
        imageType: document.getElementById('type-val'),
    };

    let state = { u: 30, h: 10, f: 20, isConverging: true };
    let isDragging = false;
    let scale = 4; // pixels per cm
    let origin = { x: 0, y: 0 };

    function resizeCanvas() {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height > 100 ? rect.height : 500;
        origin.x = canvas.width / 2;
        origin.y = canvas.height / 2;
        draw();
    }
    
    function updateStateFromInputs() {
        state.u = parseFloat(inputs.objectPos.value);
        state.h = parseFloat(inputs.objectHeight.value);
        state.f = parseFloat(inputs.focalLength.value);
        state.isConverging = inputs.lensType.value === 'converging';
    }
    
    function updateInputsFromState() {
        inputs.objectPos.value = state.u;
        inputs.objectHeight.value = state.h;
        inputs.focalLength.value = state.f;
        inputs.lensType.value = state.isConverging ? 'converging' : 'diverging';
        
        valueSpans.objectPos.textContent = `${state.u.toFixed(0)} cm`;
        valueSpans.objectHeight.textContent = `${state.h.toFixed(0)} cm`;
        valueSpans.focalLength.textContent = `${state.f.toFixed(0)} cm`;
    }

    function thinLensEquation() {
        const f = state.isConverging ? state.f : -state.f;
        if (Math.abs(state.u - f) < 0.1) return { v: Infinity, m: Infinity };
        const v = 1 / (1 / f - 1 / state.u);
        const m = -v / state.u;
        return { v, m };
    }

    function draw() {
        // Calculations
        const { v, m } = thinLensEquation();

        // Update Metrics UI
        metrics.imagePos.textContent = isFinite(v) ? `${v.toFixed(1)} cm` : 'At Infinity';
        metrics.magnification.textContent = isFinite(m) ? m.toFixed(2) : 'Infinite';
        let typeStr = v > 0 ? 'Real' : 'Virtual';
        typeStr += m < 0 ? ', Inverted' : ', Upright';
        metrics.imageType.textContent = typeStr;

        // Drawing
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Dynamic Scaling
        const maxDist = Math.max(state.u, Math.abs(state.f), Math.abs(v), 50);
        scale = (canvas.width / 2 - 40) / maxDist;
        origin.x = canvas.width / 2;

        drawAxisAndLens();
        drawFocalPoints();

        const isVirtualImage = v < 0;
        const objectX = origin.x - state.u * scale;
        const objectY = origin.y - state.h * scale;
        const imageX = origin.x + v * scale;
        const imageY = origin.y - (state.h * m) * scale;

        drawRays(objectX, objectY, imageX, imageY);
        drawObject(objectX, state.h * scale, '#38bdf8');
        drawImage(imageX, state.h * m * scale, '#f472b6', isVirtualImage);
    }
    
    function drawAxisAndLens() {
        // Principal Axis
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, origin.y);
        ctx.lineTo(canvas.width, origin.y);
        ctx.stroke();

        // Lens
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 3;
        const lensHeight = origin.y - 20;
        ctx.beginPath();
        if (state.isConverging) {
            ctx.moveTo(origin.x, 20);
            ctx.quadraticCurveTo(origin.x + 20, origin.y, origin.x, canvas.height - 20);
            ctx.moveTo(origin.x, 20);
            ctx.quadraticCurveTo(origin.x - 20, origin.y, origin.x, canvas.height - 20);
        } else { // Diverging
            ctx.moveTo(origin.x, 20);
            ctx.quadraticCurveTo(origin.x - 20, origin.y, origin.x, canvas.height - 20);
            ctx.moveTo(origin.x, 20);
            ctx.quadraticCurveTo(origin.x + 20, origin.y, origin.x, canvas.height - 20);
        }
        ctx.stroke();
    }
    
    function drawFocalPoints() {
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '12px Inter';
        const f_px = state.f * scale;
        ctx.fillText('F', origin.x + f_px - 4, origin.y + 18);
        ctx.fillText('F', origin.x - f_px - 4, origin.y + 18);
        ctx.beginPath();
        ctx.arc(origin.x + f_px, origin.y, 3, 0, Math.PI * 2);
        ctx.arc(origin.x - f_px, origin.y, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawArrow(x, y0, height, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 - height);
        // Arrowhead
        const headSize = 8;
        const headY = y0 - height;
        const direction = Math.sign(height);
        ctx.moveTo(x, headY);
        ctx.lineTo(x - headSize/2, headY + headSize * direction);
        ctx.moveTo(x, headY);
        ctx.lineTo(x + headSize/2, headY + headSize * direction);
        ctx.stroke();
    }
    
    function drawObject(x, height_px) { drawArrow(x, origin.y, height_px, 'var(--accent-color)'); }
    
    function drawImage(x, height_px, color, isVirtual) {
        if (isVirtual) {
            ctx.save();
            ctx.setLineDash([4, 4]);
            ctx.globalAlpha = 0.7;
        }
        drawArrow(x, origin.y, height_px, color);
        if (isVirtual) ctx.restore();
    }

    function drawRays(objX, objY, imgX, imgY) {
        ctx.lineWidth = 1.5;
        const f_px = state.f * scale * (state.isConverging ? 1 : -1);

        // Ray 1: Parallel -> Focal
        ctx.strokeStyle = 'var(--ray-parallel)';
        ctx.beginPath();
        ctx.moveTo(objX, objY);
        ctx.lineTo(origin.x, objY);
        ctx.lineTo(imgX, imgY);
        ctx.stroke();
        if (!state.isConverging) { // Virtual ray for diverging
            ctx.save(); ctx.setLineDash([2, 3]);
            ctx.beginPath(); ctx.moveTo(origin.x + f_px, origin.y); ctx.lineTo(origin.x, objY); ctx.stroke();
            ctx.restore();
        }

        // Ray 2: Focal -> Parallel
        ctx.strokeStyle = 'var(--ray-focal)';
        ctx.beginPath();
        ctx.moveTo(objX, objY);
        ctx.lineTo(origin.x, imgY);
        ctx.lineTo(imgX, imgY);
        ctx.stroke();
        if (state.isConverging) { // Virtual ray for object inside F
            if (state.u < state.f) {
                ctx.save(); ctx.setLineDash([2, 3]);
                ctx.beginPath(); ctx.moveTo(objX, objY); ctx.lineTo(origin.x - f_px, origin.y); ctx.stroke();
                ctx.restore();
            }
        }

        // Ray 3: Central
        ctx.strokeStyle = 'var(--ray-central)';
        ctx.beginPath();
        ctx.moveTo(objX, objY);
        ctx.lineTo(imgX, imgY);
        ctx.stroke();
    }
    
    // --- Event Handlers ---
    function handleInputChange() {
        updateStateFromInputs();
        draw();
    }
    
    function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const objectX = origin.x - state.u * scale;
        if (Math.abs(mouseX - objectX) < 15) {
            isDragging = true;
            canvas.style.cursor = 'grabbing';
        }
    }
    
    function handleMouseMove(e) {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const newU = (origin.x - mouseX) / scale;
        state.u = Math.max(1, Math.min(150, newU)); // Clamp value
        updateInputsFromState();
        draw();
    }
    
    function handleMouseUp() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    }

    // --- Initial Setup ---
    window.addEventListener('resize', resizeCanvas);
    Object.values(inputs).forEach(input => input.addEventListener('input', handleInputChange));
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    
    updateStateFromInputs();
    updateInputsFromState();
    resizeCanvas();
})();
</script>
</body>
</html>
