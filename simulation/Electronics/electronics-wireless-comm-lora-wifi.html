<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Wireless Communication Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { 
            --bg-color: #020617; 
            --card-color: rgba(15, 23, 42, 0.7);
            --border-color: #1e293b; 
            --text-light: #e2e8f0;
            --accent-color: #f97316; /* Orange */
            --success-color: #22c55e;
            --fail-color: #ef4444;
        }
        body { background-color: var(--bg-color); color: var(--text-light); font-family: 'Inter', sans-serif; }
        .glass-card { background: var(--card-color); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid var(--border-color); }
        input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: var(--border-color); border-radius: 99px; outline: none; transition: background-color 0.2s ease; }
        input[type=range]:hover { background: #334155; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            border-radius: 50%; background: var(--accent-color); border: 2px solid var(--text-light);
            cursor: pointer; transition: transform 0.1s ease-in-out, box-shadow 0.2s ease;
            box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.2);
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); box-shadow: 0 0 0 4px rgba(249, 115, 22, 0.4); }
        .sim-button {
            background: var(--accent-color); color: var(--bg-color);
            transition: all .2s ease; box-shadow: 0 4px 10px rgba(0,0,0,.3);
        }
        .sim-button:hover { background: #fb923c; transform: translateY(-2px); box-shadow: 0 6px 15px rgba(0,0,0,.4); }
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2364748b' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em;
            padding-right: 2.5rem; -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">
    <div class="container mx-auto max-w-7xl">
        <header class="mb-6 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-orange-400 to-amber-400">Wireless Communication Simulator</h1>
            <p class="mt-2 text-slate-400 max-w-2xl mx-auto">Visualize packet transmission and analyze link quality for different wireless protocols.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="glass-card shadow-2xl p-2 rounded-2xl lg:col-span-2">
                <canvas id="simulation-canvas" class="w-full h-[500px] md:h-[600px] rounded-lg"></canvas>
            </div>
            
            <div class="space-y-6">
                 <h2 class="text-2xl font-bold text-center text-slate-300">Link Parameters</h2>
                <div class="glass-card shadow-lg p-5 rounded-2xl space-y-4">
                    <h3 class="font-bold text-lg text-orange-300 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg>
                        Configuration
                    </h3>
                    <div class="text-sm space-y-4 pt-2">
                        <div>
                            <label for="protocol-type" class="font-medium text-slate-300">Protocol</label>
                            <select id="protocol-type" class="w-full mt-1 bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white">
                                <option value="wifi">Wi-Fi (54 Mbps)</option>
                                <option value="bluetooth">Bluetooth (2 Mbps)</option>
                                <option value="lora">LoRa (50 kbps)</option>
                            </select>
                        </div>
                        <div>
                            <label for="distance" class="font-medium text-slate-300 flex justify-between">Distance: <span id="distance-val">50 m</span></label>
                            <input type="range" id="distance" min="1" max="5000" value="50">
                        </div>
                        <div>
                            <label for="power" class="font-medium text-slate-300 flex justify-between">Transmit Power: <span id="power-val">20 dBm</span></label>
                            <input type="range" id="power" min="0" max="30" value="20">
                        </div>
                         <div>
                            <label for="interference" class="font-medium text-slate-300 flex justify-between">Interference: <span id="interference-val">20%</span></label>
                            <input type="range" id="interference" min="0" max="100" value="20">
                        </div>
                    </div>
                </div>

                <div class="glass-card shadow-lg p-5 rounded-2xl space-y-4">
                     <h3 class="font-bold text-lg text-orange-300 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M3 3v18h18"></path><path d="m19 9-5 5-4-4-3 3"></path></svg>
                        Live Analysis
                    </h3>
                     <div class="text-sm pt-2 space-y-2">
                        <p class="flex justify-between text-slate-400">RSSI: <span id="rssi-val" class="font-mono text-white">-50 dBm</span></p>
                        <p class="flex justify-between text-slate-400">Throughput: <span id="throughput-val" class="font-mono text-white">0.0 kbps</span></p>
                        <p class="flex justify-between text-slate-400">Packet Loss: <span id="loss-val" class="font-mono font-semibold text-green-400">0.0%</span></p>
                    </div>
                    <div class="flex gap-4 pt-4">
                        <button id="play-pause-btn" class="w-full sim-button font-bold py-3 px-4 rounded-lg flex items-center justify-center">
                            <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" class="mr-2"><path d="M8 5v14l11-7z"></path></svg>
                            <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" class="mr-2 hidden"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                            <span id="play-pause-text">Start</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
(function() {
    const canvas = document.getElementById('simulation-canvas');
    const ctx = canvas.getContext('2d');
    
    const inputs = {
        protocol: document.getElementById('protocol-type'),
        distance: document.getElementById('distance'),
        power: document.getElementById('power'),
        interference: document.getElementById('interference'),
    };
    const valueSpans = {
        distance: document.getElementById('distance-val'),
        power: document.getElementById('power-val'),
        interference: document.getElementById('interference-val'),
    };
     const analysis = {
        rssi: document.getElementById('rssi-val'),
        throughput: document.getElementById('throughput-val'),
        loss: document.getElementById('loss-val'),
    };
    
    const playPauseBtn = document.getElementById('play-pause-btn');
    const playPauseText = document.getElementById('play-pause-text');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');

    let state = { protocol: 'wifi', distance: 50, power: 20, interference: 20 };
    let sim = { running: false, packets: [], noise: [], waves: [], sent: 0, received: 0 };
    let rafId = null;
    let time = 0;
    
    const PROTOCOL_PARAMS = {
        wifi: { baseRate: 54000, sensitivity: -85, freq: 2400 },
        bluetooth: { baseRate: 2000, sensitivity: -95, freq: 2400 },
        lora: { baseRate: 50, sensitivity: -130, freq: 915 },
    };

    function resizeCanvas() {
        const simRect = canvas.parentElement.getBoundingClientRect();
        canvas.width = simRect.width;
        canvas.height = simRect.height > 100 ? simRect.height : 600;
        draw();
    }

    function resetSimulation(fullReset = true) {
        if (sim.running) togglePlayPause();
        updateStateFromInputs();
        if(fullReset) {
            sim.packets = [];
            sim.noise = [];
            sim.waves = [];
            sim.sent = 0;
            sim.received = 0;
        }
        draw();
    }
    
    function updateStateFromInputs() {
        Object.keys(inputs).forEach(key => {
            state[key] = inputs[key].value;
            if(valueSpans[key]) {
                 if (key === 'distance') {
                    const d = parseFloat(state.distance);
                    valueSpans.distance.textContent = d > 1000 ? `${(d/1000).toFixed(1)} km` : `${d.toFixed(0)} m`;
                 } else {
                    valueSpans[key].textContent = `${state[key]} ${key === 'power' ? 'dBm' : '%'}`;
                 }
            }
        });
        
        const d = parseFloat(inputs.distance.value);
        if (state.protocol === 'lora') {
            inputs.distance.max = 20000; // 20km
        } else {
            inputs.distance.max = 500; // 500m
        }

    }

    function calculateLinkQuality() {
        const params = PROTOCOL_PARAMS[state.protocol];
        const dist_m = parseFloat(state.distance);
        const power_dbm = parseFloat(state.power);
        const interference_pct = parseFloat(state.interference);

        // Friis transmission equation for path loss in dB
        const pathLoss = 20 * Math.log10(dist_m) + 20 * Math.log10(params.freq) + 20 * Math.log10(4 * Math.PI / 299792458) - 20;
        const rssi = power_dbm - pathLoss;
        
        const noiseFloor = -100; // dBm
        const interference_db = interference_pct * 0.3; // % to dB impact
        const noise = noiseFloor + interference_db;
        
        const snr = rssi - noise;

        // Simplified packet success probability based on SNR relative to sensitivity
        const margin = rssi - params.sensitivity;
        const successProbability = 1 / (1 + Math.exp(-0.5 * (margin - interference_db/2)));
        
        return { rssi, successProbability };
    }

    function physicsStep() {
        time += 0.016;
        
        // Update packets
        sim.packets.forEach(p => p.x += p.vx);
        sim.packets = sim.packets.filter(p => p.x < canvas.width * 0.9 && p.alpha > 0);

        // Update noise
        sim.noise.forEach(n => {
            n.x += n.vx; n.y += n.vy;
            if(n.x < 0 || n.x > canvas.width) n.vx *= -1;
            if(n.y < 0 || n.y > canvas.height) n.vy *= -1;
        });

        // Update waves
        sim.waves.forEach(w => {
            w.radius += 2;
            w.alpha = Math.max(0, w.alpha - 0.01);
        });
        sim.waves = sim.waves.filter(w => w.alpha > 0);

        // Create new packets and waves
        const params = PROTOCOL_PARAMS[state.protocol];
        const packetsPerSecond = params.baseRate / 1500 / 8; // Assuming 1500 byte packets
        if (Math.random() < packetsPerSecond * 0.1) {
            const { rssi, successProbability } = calculateLinkQuality();
            sim.sent++;
            let success = Math.random() < successProbability;
            if(success) sim.received++;

            sim.packets.push({
                x: canvas.width * 0.1,
                y: canvas.height / 2 + (Math.random() - 0.5) * 20,
                vx: 5,
                success: success,
                alpha: 1
            });
        }
        
        if (Math.random() < 0.2) {
            sim.waves.push({radius: 0, alpha: 1});
        }
        
        // Update analysis
        const { rssi, successProbability } = calculateLinkQuality();
        const loss = sim.sent > 0 ? (1 - sim.received / sim.sent) * 100 : 0;
        const throughput = params.baseRate * (1 - loss/100);

        analysis.rssi.textContent = `${rssi.toFixed(1)} dBm`;
        analysis.loss.textContent = `${loss.toFixed(1)}%`;
        analysis.loss.style.color = loss > 20 ? 'var(--fail-color)' : 'var(--success-color)';
        analysis.throughput.textContent = `${(throughput).toFixed(1)} kbps`;
    }

    function loop() {
        if (!sim.running) return;
        physicsStep();
        draw();
        rafId = requestAnimationFrame(loop);
    }

    function draw() {
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        drawNodes();
        drawWaves();
        drawPackets();
        drawNoise();
    }
    
    function drawNodes() {
        const x1 = canvas.width * 0.1, x2 = canvas.width * 0.9, y = canvas.height/2;
        drawAntenna(x1, y, 'Transmitter');
        drawAntenna(x2, y, 'Receiver');
    }

    function drawAntenna(x,y,label) {
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(x-10, y, 20, 20);
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x,y);
        ctx.lineTo(x, y-30);
        ctx.stroke();
        ctx.font = '12px Inter';
        ctx.fillStyle = '#e2e8f0';
        ctx.textAlign = 'center';
        ctx.fillText(label, x, y + 40);
    }
    
    function drawWaves() {
        const x = canvas.width * 0.1, y = canvas.height/2;
        const maxRadius = 30 + state.power * 5;
        sim.waves.forEach(w => {
            ctx.strokeStyle = `rgba(249, 115, 22, ${w.alpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, w.radius, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            if(w.radius < maxRadius) {
                 w.radius+=2;
            } else {
                 w.alpha = Math.max(0, w.alpha - 0.02);
            }
        });
         sim.waves = sim.waves.filter(w => w.alpha > 0);
    }
    
    function drawPackets() {
        sim.packets.forEach(p => {
            if (!p.success && p.x > canvas.width * 0.2) {
                p.alpha -= 0.05;
            }
            ctx.fillStyle = p.success ? `rgba(34, 197, 94, ${p.alpha})` : `rgba(239, 68, 68, ${p.alpha})`;
            ctx.fillRect(p.x, p.y - 5, 10, 10);
        });
    }

    function drawNoise() {
        while(sim.noise.length < state.interference * 2) {
            sim.noise.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, vx: (Math.random()-0.5), vy: (Math.random()-0.5), size: Math.random()*2+1});
        }
        while(sim.noise.length > state.interference * 2) {
            sim.noise.pop();
        }
        ctx.fillStyle = 'rgba(156, 163, 175, 0.5)';
        sim.noise.forEach(n => {
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.size, 0, Math.PI*2);
            ctx.fill();
        });
    }
    
    function togglePlayPause() {
        sim.running = !sim.running;
        if (sim.running) {
            playPauseText.textContent = 'Pause';
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
            loop();
        } else {
            playPauseText.textContent = 'Start';
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
            if(rafId) cancelAnimationFrame(rafId);
        }
    }

    // --- Event Handlers ---
    Object.values(inputs).forEach(input => input.addEventListener('input', () => {
        updateStateFromInputs();
        if(!sim.running) draw();
    }));
    playPauseBtn.addEventListener('click', togglePlayPause);
    
    resetSimulation();
    window.addEventListener('resize', resizeCanvas);
})();
</script>
</body>
</html>

