<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Science Lab Collection</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-dark: #0f172a;
        --bg-dark-secondary: #1e293b;
        --border-color: #334155;
        --text-primary: #f8fafc;
        --text-secondary: #cbd5e1;
        --accent-blue: #3b82f6; /* Physics */
        --accent-emerald: #10b981; /* Chemistry */
        --accent-teal: #14b8a6; /* Biology */
        --accent-lime: #84cc16; /* Environmental Science */
        --accent-orange: #f97316; /* Electronics & IoT */
      }
      body {
        font-family: "Inter", sans-serif;
        background-color: var(--bg-dark);
        color: var(--text-primary);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      .page {
        display: none;
      }
      .page.active {
        display: block;
        animation: fadeIn 0.5s ease-in-out;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .glass-card {
        background: rgba(30, 41, 59, 0.5);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--border-color);
        transition: all 0.3s ease;
      }
      .glass-card:hover {
        border-color: rgba(59, 130, 246, 0.5);
        transform: translateY(-8px);
        box-shadow: 0 20px 30px rgba(0, 0, 0, 0.2);
      }
      .subject-card {
        background-size: cover;
        background-position: center;
        position: relative;
        overflow: hidden;
      }
      .subject-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          to top,
          rgba(15, 23, 42, 0.9),
          rgba(15, 23, 42, 0.3)
        );
        transition: background 0.3s ease;
      }
      .subject-card:hover::after {
        background: linear-gradient(
          to top,
          rgba(15, 23, 42, 0.7),
          rgba(15, 23, 42, 0.1)
        );
      }
      .sidebar-link {
        transition: all 0.2s ease;
      }
      .sidebar-link.active,
      .sidebar-link:hover {
        color: var(--text-primary);
        transform: translateX(4px);
      }
      .sidebar-link.physics.active,
      .sidebar-link.physics:hover {
        background-color: var(--accent-blue);
      }
      .sidebar-link.chemistry.active,
      .sidebar-link.chemistry:hover {
        background-color: var(--accent-emerald);
      }
      .sidebar-link.biology.active,
      .sidebar-link.biology:hover {
        background-color: var(--accent-teal);
      }
      .sidebar-link.environmentalScience.active,
      .sidebar-link.environmentalScience:hover {
        background-color: var(--accent-lime);
      }
      .sidebar-link.electronicsIot.active,
      .sidebar-link.electronicsIot:hover {
        background-color: var(--accent-orange);
      }
      .sim-button {
        transition: all 0.2s ease-in-out;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      }
      .sim-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
      }
      .sim-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .sim-button.physics {
        background: var(--accent-blue);
      }
      .sim-button.chemistry {
        background: var(--accent-emerald);
      }
      .sim-button.biology {
        background: var(--accent-teal);
      }
      .sim-button.environmentalScience {
        background: var(--accent-lime);
      }
      .sim-button.electronicsIot {
        background: var(--accent-orange);
      }
      .slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        cursor: pointer;
        border-radius: 50%;
        border: 2px solid white;
      }
      .slider-thumb.physics {
        background: var(--accent-blue);
        box-shadow: 0 0 5px rgba(59, 130, 246, 0.7);
      }
      .slider-thumb.chemistry {
        background: var(--accent-emerald);
        box-shadow: 0 0 5px rgba(16, 185, 129, 0.7);
      }
      .slider-thumb.biology {
        background: var(--accent-teal);
        box-shadow: 0 0 5px rgba(20, 184, 166, 0.7);
      }
      .slider-thumb.environmentalScience {
        background: var(--accent-lime);
        box-shadow: 0 0 5px rgba(132, 204, 22, 0.7);
      }
      .slider-thumb.electronicsIot {
        background: var(--accent-orange);
        box-shadow: 0 0 5px rgba(249, 115, 22, 0.7);
      }
      input[type="range"] {
        background: var(--border-color);
        border-radius: 99px;
      }
      canvas {
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <!-- Main Landing Page -->
    <div id="home-page" class="page active">
      <div
        class="container mx-auto px-4 py-8 md:py-16 min-h-screen flex flex-col justify-center"
      >
        <header class="text-center mb-12">
          <h1
            class="text-4xl md:text-6xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-lime-400"
          >
            Virtual Science Lab
          </h1>
          <p class="mt-4 text-lg text-slate-400">
            Choose a subject to begin your exploration.
          </p>
        </header>
        <div
          class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8 max-w-7xl mx-auto w-full"
        >
          <!-- Physics Card -->
          <div
            id="select-physics"
            class="subject-card glass-card h-80 rounded-2xl flex items-end p-8 cursor-pointer"
            style="
              background-image: url('https://placehold.co/600x400/0f172a/f8fafc?text=Physics');
            "
          >
            <div class="relative z-10">
              <h2 class="text-3xl font-bold text-white">Physics</h2>
              <p class="text-slate-300 mt-2">
                Laws of motion, energy, and the universe.
              </p>
            </div>
          </div>
          <!-- Chemistry Card -->
          <div
            id="select-chemistry"
            class="subject-card glass-card h-80 rounded-2xl flex items-end p-8 cursor-pointer"
            style="
              background-image: url('https://placehold.co/600x400/0f172a/f8fafc?text=Chemistry');
            "
          >
            <div class="relative z-10">
              <h2 class="text-3xl font-bold text-white">Chemistry</h2>
              <p class="text-slate-300 mt-2">
                Reactions, molecules, and matter.
              </p>
            </div>
          </div>
          <!-- Biology Card -->
          <div
            id="select-biology"
            class="subject-card glass-card h-80 rounded-2xl flex items-end p-8 cursor-pointer"
            style="
              background-image: url('https://placehold.co/600x400/0f172a/f8fafc?text=Biology');
            "
          >
            <div class="relative z-10">
              <h2 class="text-3xl font-bold text-white">Biology</h2>
              <p class="text-slate-300 mt-2">
                Life, organisms, and ecosystems.
              </p>
            </div>
          </div>
          <!-- Environmental Science Card -->
          <div
            id="select-environmentalScience"
            class="subject-card glass-card h-80 rounded-2xl flex items-end p-8 cursor-pointer"
            style="
              background-image: url('https://placehold.co/600x400/0f172a/f8fafc?text=Env.+Science');
            "
          >
            <div class="relative z-10">
              <h2 class="text-3xl font-bold text-white">
                Environmental Science
              </h2>
              <p class="text-slate-300 mt-2">
                Ecology, climate, and sustainability.
              </p>
            </div>
          </div>
          <!-- Electronics & IoT Card -->
          <div
            id="select-electronicsIot"
            class="subject-card glass-card h-80 rounded-2xl flex items-end p-8 cursor-pointer"
            style="
              background-image: url('https://placehold.co/600x400/0f172a/f8fafc?text=Electronics');
            "
          >
            <div class="relative z-10">
              <h2 class="text-3xl font-bold text-white">Electronics & IoT</h2>
              <p class="text-slate-300 mt-2">
                Circuits, sensors, and connectivity.
              </p>
            </div>
          </div>
          <div class="lg:col-span-1"></div>
          <!-- Spacer for alignment -->
        </div>
      </div>
    </div>

    <!-- Subject Page (Experiment Grid) -->
    <div id="subject-page" class="page">
      <div class="container mx-auto px-4 py-8 md:py-16">
        <header class="text-center mb-12">
          <button
            id="back-to-home-from-subject"
            class="flex items-center gap-2 text-sm font-medium text-slate-400 hover:text-white mb-6 transition-colors mx-auto"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M15 18l-6-6 6-6" />
            </svg>
            Back to Subjects
          </button>
          <h1
            id="subject-title"
            class="text-4xl md:text-6xl font-bold text-transparent bg-clip-text bg-gradient-to-r"
          ></h1>
          <p class="mt-4 text-lg text-slate-400">
            Select an experiment to begin.
          </p>
        </header>
        <div
          id="experiment-grid"
          class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-8"
        >
          <!-- Experiment cards injected by JS -->
        </div>
      </div>
    </div>

    <!-- Experiment Page -->
    <div id="experiment-page" class="page">
      <div class="flex flex-col md:flex-row min-h-screen">
        <!-- Sidebar -->
        <aside
          class="w-full md:w-64 lg:w-72 bg-slate-900 border-r border-slate-700 p-4 md:p-6 md:sticky top-0 h-auto md:h-screen shrink-0"
        >
          <button
            id="back-to-subject"
            class="flex items-center gap-2 text-sm font-medium text-slate-400 hover:text-white mb-6 transition-colors w-full"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M15 18l-6-6 6-6" />
            </svg>
            Back to Experiments
          </button>
          <h2
            id="experiment-title-sidebar"
            class="text-lg font-semibold text-white mb-4 truncate"
          ></h2>
          <nav id="experiment-nav" class="space-y-2">
            <!-- Nav links injected by JS -->
          </nav>
        </aside>
        <!-- Main Content -->
        <main class="flex-1 p-4 sm:p-6 md:p-10 bg-slate-800">
          <div id="experiment-content" class="max-w-5xl mx-auto">
            <!-- Content injected by JS -->
          </div>
        </main>
      </div>
    </div>

    <script>
      // --- DATA STORE for all experiment content ---
      // --- DATA STORE for all experiment content ---
      const experiments = {
        physics: {
          "projectile-motion": {
            title: "Projectile Motion Simulator",
            description:
              "Explore motion of projectiles with adjustable angle, speed, mass, and air resistance.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M22 2 11 13"/><path d="m22 2-7 20-4-9-9-4 20-7z"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand kinematic equations for projectile motion</li><li>Analyze tradeoffs between range and maximum height</li><li>Investigate the role of air resistance (drag) on trajectory</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Projectile motion is the path an object takes when launched into the air, subject only to the acceleration of gravity. In a vacuum, this path is a perfect parabola. The motion is analyzed by splitting it into independent horizontal and vertical components.</p><p>Key formulas include: <code class="bg-slate-700 px-1 rounded">Range = (v₀² * sin(2θ)) / g</code> and <code class="bg-slate-700 px-1 rounded">Max Height = (v₀² * sin²(θ)) / (2g)</code>. Air resistance causes the actual trajectory to be shorter and lower than the ideal path.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Set parameters for initial speed, launch angle, and drag using the sliders</li><li>Click the 'Fire' button to launch the projectile</li><li>Observe the trajectory and compare with ideal path</li><li>Record maximum range and height for different configurations</li><li>Analyze how parameters affect the projectile motion</li></ol>`,
              },
              simulation: {
                title: "Simulation: Projectile Motion",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="projectile-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md cursor-crosshair border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="velocity" class="font-medium">Initial Speed (<span id="velocity-val">50</span> m/s)</label><input type="range" id="velocity" min="10" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="angle" class="font-medium">Launch Angle (<span id="angle-val">45</span>°)</label><input type="range" id="angle" min="0" max="90" value="45" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="flex items-center"><input type="checkbox" id="air-resistance" class="h-4 w-4 rounded border-gray-500 text-blue-500 focus:ring-blue-500 bg-slate-700"><label for="air-resistance" class="ml-2 block text-sm">Enable Air Resistance</label></div></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Max Height:</strong> <span id="max-height" class="font-semibold">0.00</span> m</p><p><strong>Range:</strong> <span id="range" class="font-semibold">0.00</span> m</p><div class="flex gap-2 pt-2"><button id="fire-btn" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Fire</button><button id="reset-btn" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700 transition-colors">Reset</button></div></div></div></div>`,
              },
            },
          },
          "simple-harmonic-motion": {
            title: "Simple Harmonic Motion: Mass-Spring System",
            description:
              "Simulate mass-spring oscillations with damping and driving force.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M12 3v2"/><path d="M12 7v2"/><path d="M12 11v2"/><path d="M12 15v2"/><path d="M12 19v2"/><rect width="12" height="4" x="6" y="5" rx="2"/><rect width="12" height="4" x="6" y="15" rx="2"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand Hooke\'s Law and its relation to oscillations</li><li>Define and measure natural frequency</li><li>Investigate damping and the Quality (Q) factor</li><li>Observe the phenomenon of resonance</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Simple Harmonic Motion (SHM) describes oscillatory motion where the restoring force is directly proportional to the displacement (e.g., a mass on a spring). The natural frequency is the frequency at which the system oscillates without any driving or damping forces.</p><p>Damping is a force that reduces the amplitude of oscillations over time. When a periodic driving force is applied, the system\'s amplitude is maximized when the driving frequency matches the natural frequency, a condition known as resonance.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Adjust the spring constant, mass, and damping parameters</li><li>Click 'Start' to see the natural oscillation</li><li>Apply a driving force by adjusting the driving frequency and amplitude</li><li>Observe the amplitude vs. driving frequency plot to find the resonance peak</li><li>Analyze how damping affects the resonance curve</li></ol>`,
              },
              simulation: {
                title: "Simulation: Mass-Spring System",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><div class="grid grid-cols-1 lg:grid-cols-2 gap-4"><div class="w-full h-48 bg-gray-900 rounded-md border border-slate-700"><canvas id="shm-time-canvas"></canvas></div><div class="w-full h-48 bg-gray-900 rounded-md border border-slate-700"><canvas id="shm-freq-canvas"></canvas></div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label class="font-medium">Spring Constant (k): <span id="k-val">20</span></label><input type="range" id="k-slider" min="5" max="50" value="20" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label class="font-medium">Mass (m): <span id="m-val">1</span></label><input type="range" id="m-slider" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label class="font-medium">Damping (b): <span id="b-val">0.2</span></label><input type="range" id="b-slider" min="0" max="2" step="0.1" value="0.2" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label class="font-medium">Driving Freq (rad/s): <span id="df-val">1.0</span></label><input type="range" id="df-slider" min="0.1" max="10" step="0.1" value="1" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label class="font-medium">Driving Amp (F₀): <span id="da-val">0</span></label><input type="range" id="da-slider" min="0" max="20" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="flex gap-2"><button id="start-shm-btn" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start</button><button id="reset-shm-btn" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Reset</button></div></div></div></div>`,
              },
            },
          },
          "electric-circuits": {
            title: "Electric Circuits: RC, RL, and RLC Transients",
            description:
              "Virtual bench for step response and frequency response of simple circuits.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M6 9h6"/><path d="M10 15v6"/><path d="M9 21h6"/><path d="M10 3v6"/><rect x="3" y="3" width="18" height="18" rx="2"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand time constants in RC and RL circuits</li><li>Analyze impulse and step response</li><li>Investigate resonance in RLC circuits</li><li>Measure phase shift in AC circuits</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">RC, RL, and RLC circuits exhibit characteristic transient responses when subjected to step changes in voltage or current. The time constant (τ = RC or τ = L/R) determines how quickly the circuit reaches steady state.</p><p>RLC circuits can exhibit resonance when the inductive and capacitive reactances cancel, leading to maximum current amplitude at the resonant frequency.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Build RC, RL, or RLC circuits using the virtual components</li><li>Apply step or sine wave input from the function generator</li><li>Observe voltage and current vs time on the oscilloscope</li><li>Measure time constants and resonant frequencies</li><li>Analyze frequency response and phase relationships</li></ol>`,
              },
              simulation: {
                title: "Simulation: Circuit Builder",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="circuit-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="voltage" class="font-medium">Voltage (<span id="voltage-val">12</span> V)</label><input type="range" id="voltage" min="1" max="24" value="12" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="resistor1" class="font-medium">Resistor 1 (<span id="resistor1-val">100</span> Ω)</label><input type="range" id="resistor1" min="10" max="1000" value="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="resistor2" class="font-medium">Resistor 2 (<span id="resistor2-val">200</span> Ω)</label><input type="range" id="resistor2" min="10" max="1000" value="200" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="circuit-type" class="font-medium">Circuit Type</label><select id="circuit-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="series">Series</option><option value="parallel">Parallel</option></select></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Current:</strong> <span id="current-display" class="font-semibold">0.000</span> A</p><p><strong>Power:</strong> <span id="power-display" class="font-semibold">0.000</span> W</p><div class="flex gap-2 pt-2"><button id="analyze-btn" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Analyze</button></div></div></div></div></div>`,
              },
            },
          },
          "optics-ray-tracing": {
            title: "Optics: Ray Tracing & Lens Systems",
            description:
              "Ray-trace lenses and mirrors; investigate image formation, magnification, aberrations.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><circle cx="12" cy="12" r="6"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Apply the lens equation to calculate image properties</li><li>Understand focal length and its relationship to image formation</li><li>Differentiate between real and virtual images</li><li>Identify common optical aberrations</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">The thin lens equation relates object distance (u), image distance (v), and focal length (f): 1/u + 1/v = 1/f. Magnification is given by M = -v/u.</p><p>Real images are formed when light rays actually converge, while virtual images appear where light rays seem to diverge from. Optical aberrations like spherical aberration and chromatic aberration cause imperfections in image formation.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Place objects at different distances from the lens</li><li>Vary lens parameters and observe image formation</li><li>Measure image location and compare to theoretical predictions</li><li>Identify different types of optical aberrations</li><li>Analyze how lens systems affect image quality</li></ol>`,
              },
              simulation: {
                title: "Simulation: Ray Tracing",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="optics-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="object-pos" class="font-medium">Object Position (<span id="object-pos-val">30</span> cm)</label><input type="range" id="object-pos" min="10" max="100" value="30" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="focal-length" class="font-medium">Focal Length (<span id="focal-length-val">20</span> cm)</label><input type="range" id="focal-length" min="5" max="50" value="20" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="lens-type" class="font-medium">Lens Type</label><select id="lens-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="converging">Converging</option><option value="diverging">Diverging</option></select></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Image Position:</strong> <span id="image-pos" class="font-semibold">60.0</span> cm</p><p><strong>Magnification:</strong> <span id="magnification" class="font-semibold">-2.00</span></p></div></div></div></div>`,
              },
            },
          },
          "energy-pendulum": {
            title: "Energy & Power: Pendulum and Energy Conversion",
            description:
              "Simulate pendulum with energy plots (kinetic, potential, total). Include friction.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><circle cx="12" cy="5" r="3"/><path d="M12 22V8"/><path d="M5 12H2a10 10 0 0 0 20 0h-3"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand conservation of mechanical energy</li><li>Analyze energy loss due to friction</li><li>Apply the small-angle approximation</li><li>Investigate the relationship between period and length</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">A pendulum demonstrates the continuous conversion between potential and kinetic energy. For small angles (θ < 15°), the period is approximately T = 2π√(L/g), independent of mass and amplitude.</p><p>Friction causes gradual energy dissipation, converting mechanical energy to heat. The total mechanical energy decreases exponentially with time in damped oscillations.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Vary pendulum length and initial angle</li><li>Measure period and compare to theoretical predictions</li><li>Plot kinetic, potential, and total energy vs time</li><li>Analyze how friction affects energy conservation</li><li>Investigate the limits of the small-angle approximation</li></ol>`,
              },
              simulation: {
                title: "Simulation: Energy Pendulum",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><div class="grid grid-cols-1 lg:grid-cols-2 gap-4"><div class="w-full h-48 bg-gray-900 rounded-md border border-slate-700"><canvas id="pendulum-canvas"></canvas></div><div class="w-full h-48 bg-gray-900 rounded-md border border-slate-700"><canvas id="energy-graph"></canvas></div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="pendulum-length" class="font-medium">Length (<span id="length-val">1.0</span> m)</label><input type="range" id="pendulum-length" min="0.5" max="3.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="gravity" class="font-medium">Gravity (<span id="gravity-val">9.81</span> m/s²)</label><input type="range" id="gravity" min="1" max="20" step="0.1" value="9.81" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="initial-angle" class="font-medium">Initial Angle (<span id="angle-val">30</span>°)</label><input type="range" id="initial-angle" min="5" max="80" value="30" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="pendulum-mass" class="font-medium">Mass (<span id="mass-val">1.0</span> kg)</label><input type="range" id="pendulum-mass" min="0.1" max="5.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="flex gap-2 pt-6"><button id="start-pendulum" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start</button><button id="stop-pendulum" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button></div></div></div></div>`,
              },
            },
          },
        },

        chemistry: {
          "virtual-titration": {
            title: "Virtual Titration: Acid-Base Titration Curves",
            description:
              "Simulate titration of strong/weak acids and bases with pH meter and indicators.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-emerald-400"><path d="m14.5 2 6 6"/><path d="M14 2v6h6"/><path d="M10 10H5a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-2"/><path d="M7 16h.01"/><path d="M11 16h.01"/><path d="M15 16h.01"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Identify equivalence points in acid-base titrations</li><li>Understand buffer regions and their significance</li><li>Estimate pKa values from titration curves</li><li>Compare strong vs weak acid/base behavior</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Titration is an analytical method used to determine the concentration of an unknown solution by reacting it with a solution of known concentration. The equivalence point occurs when stoichiometrically equivalent amounts of acid and base have reacted.</p><p>For weak acids, the pH at half-equivalence equals the pKa. Buffer regions resist pH changes and occur when significant amounts of both weak acid and its conjugate base are present.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Select acid and base concentrations</li><li>Choose an appropriate pH indicator</li><li>Slowly add titrant while monitoring pH changes</li><li>Record the equivalence point and buffer regions</li><li>Determine unknown concentrations and estimate pKa values</li></ol>`,
              },
              simulation: {
                title: "Simulation: Virtual Titration",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="titration-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="acid-concentration" class="font-medium">Acid Concentration (<span id="acid-val">0.1</span> M)</label><input type="range" id="acid-concentration" min="0.01" max="1.0" step="0.01" value="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="base-concentration" class="font-medium">Base Concentration (<span id="base-val">0.1</span> M)</label><input type="range" id="base-concentration" min="0.01" max="1.0" step="0.01" value="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="volume-added" class="font-medium">Volume Added (<span id="volume-val">0</span> mL)</label><input type="range" id="volume-added" min="0" max="100" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="indicator" class="font-medium">Indicator</label><select id="indicator" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="phenolphthalein">Phenolphthalein</option><option value="methyl-orange">Methyl Orange</option><option value="universal">Universal</option></select></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>pH Value:</strong> <span id="ph-value" class="font-semibold">1.00</span></p><div class="flex gap-2 pt-2"><button id="add-base" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Add Base</button><button id="reset-titration" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Reset</button></div></div></div></div></div>`,
              },
            },
          },
          "chemical-kinetics": {
            title: "Chemical Kinetics: Rate Laws & Activation Energy",
            description:
              "Run simulated reactions with adjustable temperature, concentration, catalysts; measure rate.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-emerald-400"><path d="m12 15 2.5-2.5"/><path d="m12 15-2.5 2.5"/><path d="M12 15v5"/><path d="M12 5v5"/><path d="M5 12h14"/><circle cx="12" cy="12" r="10"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Determine order of reaction from concentration data</li><li>Construct Arrhenius plots to find activation energy</li><li>Analyze the effect of catalysts on reaction rates</li><li>Understand collision theory and reaction mechanisms</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Chemical kinetics studies the rates of chemical reactions. The rate law expresses the relationship between reaction rate and reactant concentrations: rate = k[A]^m[B]^n.</p><p>The Arrhenius equation relates rate constant to temperature: k = Ae^(-Ea/RT). Catalysts provide alternative reaction pathways with lower activation energies, increasing reaction rates without being consumed.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Vary initial concentrations and measure initial rates</li><li>Determine reaction order with respect to each reactant</li><li>Run reactions at different temperatures</li><li>Construct Arrhenius plot to find activation energy</li><li>Add catalysts and observe their effect on reaction rate</li></ol>`,
              },
              simulation: {
                title: "Simulation: Reaction Kinetics",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="kinetics-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="temperature" class="font-medium">Temperature (<span id="temp-val">300</span> K)</label><input type="range" id="temperature" min="273" max="373" value="300" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="concentration" class="font-medium">Concentration (<span id="conc-val">50</span>%)</label><input type="range" id="concentration" min="10" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="catalyst" class="font-medium">Catalyst (<span id="catalyst-val">0</span>%)</label><input type="range" id="catalyst" min="0" max="100" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Reaction Time:</strong> <span id="reaction-time" class="font-semibold">0.0</span> s</p><p><strong>Reaction Rate:</strong> <span id="reaction-rate" class="font-semibold">0.000</span> M/s</p><div class="flex gap-2 pt-2"><button id="start-kinetics" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start</button><button id="stop-kinetics" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button><button id="reset-kinetics" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Reset</button></div></div></div></div></div>`,
              },
            },
          },
          "electrochemistry-galvanic-cells": {
            title: "Electrochemistry: Galvanic Cells & Nernst Equation",
            description:
              "Build virtual galvanic cells, change concentrations, measure voltage under load.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-emerald-400"><path d="M2 12h20"/><path d="M20 12v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-8"/><path d="m4 8 8-4 8 4"/><path d="m6 16 8 4 8-4"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand standard electrode potentials</li><li>Calculate cell EMF using the Nernst equation</li><li>Analyze concentration effects on cell voltage</li><li>Identify anode and cathode in galvanic cells</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Galvanic cells convert chemical energy to electrical energy through spontaneous redox reactions. The standard cell potential (E°cell) is calculated from standard reduction potentials: E°cell = E°cathode - E°anode.</p><p>The Nernst equation accounts for concentration effects: E = E° - (RT/nF)lnQ, where Q is the reaction quotient. Under load, cell voltage decreases due to polarization and internal resistance.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Assemble galvanic cells with different electrode pairs</li><li>Measure open-circuit and loaded voltages</li><li>Change solution concentrations and observe voltage changes</li><li>Compare experimental results with Nernst equation predictions</li><li>Analyze polarization effects under different load conditions</li></ol>`,
              },
              simulation: {
                title: "Simulation: Galvanic Cell",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="electrochem-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="metal1" class="font-medium">Anode Metal</label><select id="metal1" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="Zn">Zinc (Zn)</option><option value="Fe">Iron (Fe)</option><option value="Pb">Lead (Pb)</option></select></div><div><label for="metal2" class="font-medium">Cathode Metal</label><select id="metal2" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="Cu">Copper (Cu)</option><option value="Ag">Silver (Ag)</option><option value="Au">Gold (Au)</option></select></div><div><label for="solution-concentration" class="font-medium">Solution Concentration (<span id="conc-val">1.0</span> M)</label><input type="range" id="solution-concentration" min="0.1" max="2.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Cell Voltage:</strong> <span id="cell-voltage" class="font-semibold">1.10</span> V</p><p><strong>Cell Current:</strong> <span id="cell-current" class="font-semibold">0.000</span> A</p><div class="flex gap-2 pt-2"><button id="measure-voltage" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Measure</button></div></div></div></div></div>`,
              },
            },
          },
          "equilibrium-le-chatelier": {
            title: "Equilibrium: Le Chatelier's Principle in Action",
            description:
              "Simulate reversible reactions with perturbations (T, P, concentration) and track shift.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-emerald-400"><path d="m3 10 3-3 3 3"/><path d="M6 7v14"/><path d="m21 10-3-3-3 3"/><path d="M18 7v14"/><path d="M12 3v18"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand the equilibrium constant K</li><li>Apply Le Chatelier\'s principle to predict equilibrium shifts</li><li>Analyze response to temperature, pressure, and concentration changes</li><li>Distinguish between homogeneous and heterogeneous equilibria</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Chemical equilibrium occurs when forward and reverse reaction rates are equal. The equilibrium constant K expresses the ratio of product to reactant concentrations at equilibrium.</p><p>Le Chatelier\'s principle states that if a system at equilibrium is disturbed, it will shift to counteract the disturbance. Temperature changes affect K for exothermic/endothermic reactions, while pressure and concentration changes affect equilibrium position but not K.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Establish initial equilibrium conditions</li><li>Perturb the system by changing temperature, pressure, or concentration</li><li>Observe how the equilibrium shifts in response</li><li>Calculate equilibrium constants from concentration data</li><li>Predict and verify equilibrium shifts for various disturbances</li></ol>`,
              },
              simulation: {
                title: "Simulation: Equilibrium System",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="equilibrium-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="eq-temperature" class="font-medium">Temperature (<span id="temp-val">300</span> K)</label><input type="range" id="eq-temperature" min="250" max="350" value="300" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="pressure" class="font-medium">Pressure (<span id="pressure-val">1.0</span> atm)</label><input type="range" id="pressure" min="0.5" max="2.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="initial-concentration" class="font-medium">Initial Concentration (<span id="init-conc-val">50</span>%)</label><input type="range" id="initial-concentration" min="10" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Equilibrium Constant:</strong> <span id="equilibrium-constant" class="font-semibold">1.000</span></p><p><strong>Reaction Progress:</strong> <span id="reaction-progress" class="font-semibold">50.0</span>%</p><div class="flex gap-2 pt-2"><button id="start-equilibrium" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start</button><button id="stop-equilibrium" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button><button id="reset-equilibrium" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Reset</button></div></div></div></div></div>`,
              },
            },
          },
          "molecular-modeling": {
            title: "Molecular Modeling: Visualize Bonding & IR Spectra",
            description:
              "Build small molecules, visualize orbitals, calculate approximate vibrational modes and IR peaks.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-emerald-400"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand bond polarity and molecular geometry</li><li>Identify functional groups from molecular structures</li><li>Correlate vibrational modes to IR spectral peaks</li><li>Visualize molecular orbitals and electron density</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Molecular modeling uses computational methods to predict molecular properties. Bond polarity arises from differences in electronegativity, affecting molecular behavior and spectra.</p><p>Infrared spectroscopy detects vibrational transitions that occur when molecular bonds absorb IR radiation. Each functional group has characteristic vibrational frequencies that appear as peaks in IR spectra.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Build molecules using the molecular builder</li><li>Analyze molecular geometry and bond properties</li><li>Run vibrational mode analysis</li><li>Compare predicted IR peaks to reference spectra</li><li>Identify functional groups from spectral data</li></ol>`,
              },
              simulation: {
                title: "Simulation: Molecular Viewer",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="molecular-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="molecule-type" class="font-medium">Molecule Type</label><select id="molecule-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="water">Water (H₂O)</option><option value="methane">Methane (CH₄)</option><option value="ammonia">Ammonia (NH₃)</option></select></div><div><label for="view-type" class="font-medium">View Type</label><select id="view-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="wireframe">Wireframe</option><option value="ball-stick">Ball and Stick</option><option value="space-filling">Space Filling</option></select></div></div><div class="space-y-4"><div><label for="bond-length" class="font-medium">Bond Length (<span id="bond-val">1.0</span> Å)</label><input type="range" id="bond-length" min="0.5" max="2.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="bond-angle" class="font-medium">Bond Angle (<span id="angle-val">109.5</span>°)</label><input type="range" id="bond-angle" min="90" max="180" value="109.5" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="flex gap-2 pt-2"><button id="rotate-molecule" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Rotate</button></div></div></div></div>`,
              },
            },
          },
        },

        biology: {
          "cell-structure-explorer": {
            title: "Cell Structure Explorer (3D)",
            description:
              "Interactive 3D cells where students toggle organelles, zoom, and run virtual staining.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-teal-400"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Identify and understand organelle functions</li><li>Differentiate between prokaryotic and eukaryotic cells</li><li>Understand cell membrane structure and function</li><li>Explore specialized cell types and their adaptations</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Cells are the basic structural and functional units of life. Eukaryotic cells contain membrane-bound organelles, while prokaryotic cells lack these structures.</p><p>Key organelles include the nucleus (genetic control), mitochondria (energy production), endoplasmic reticulum (protein synthesis), Golgi apparatus (modification and packaging), and lysosomes (digestion).</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Explore 3D cell models using zoom and rotation</li><li>Toggle organelle visibility to study individual structures</li><li>Apply virtual staining to highlight specific components</li><li>Compare animal and plant cell structures</li><li>Complete interactive labeling exercises</li></ol>`,
              },
              simulation: {
                title: "Simulation: Cell Explorer",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="cell-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="cell-type" class="font-medium">Cell Type</label><select id="cell-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="animal">Animal Cell</option><option value="plant">Plant Cell</option></select></div><div><label for="cell-zoom" class="font-medium">Zoom Level (<span id="zoom-val">1.0</span>x)</label><input type="range" id="cell-zoom" min="0.5" max="3.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="cell-structure" class="font-medium">Highlight Structure</label><select id="cell-structure" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="all">All Structures</option><option value="nucleus">Nucleus</option><option value="mitochondria">Mitochondria</option><option value="chloroplast">Chloroplast</option></select></div><div class="flex gap-2 pt-6"><button id="rotate-cell" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Rotate View</button></div></div></div></div>`,
              },
            },
          },
          "enzyme-kinetics": {
            title: "Enzyme Kinetics: Michaelis-Menten Simulator",
            description:
              "Simulated enzyme assays to measure Vmax and Km, with options for inhibitors.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-teal-400"><path d="m9.06 11.9 4.47-4.48"/><path d="m12.54 7.41 1.65-1.65a5 5 0 0 1 7.07 7.07l-1.65 1.65"/><path d="M9.06 11.9 7.41 13.54a5 5 0 0 0-7.07-7.07l1.65-1.65"/><path d="m14.94 12.1-4.47 4.48"/><path d="m11.46 16.59-1.65 1.65a5 5 0 0 1-7.07-7.07l1.65-1.65"/><path d="m14.94 12.1 1.65-1.65a5 5 0 0 0 7.07 7.07l-1.65 1.65"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand Michaelis-Menten enzyme kinetics</li><li>Construct and interpret Lineweaver-Burk plots</li><li>Differentiate between competitive and noncompetitive inhibition</li><li>Determine Km and Vmax from experimental data</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">The Michaelis-Menten equation describes enzyme kinetics: v = (Vmax × [S]) / (Km + [S]), where Vmax is the maximum reaction rate and Km is the substrate concentration at half Vmax.</p><p>Lineweaver-Burk plots (1/v vs 1/[S]) provide linear transformations for determining Km and Vmax. Enzyme inhibitors can be competitive (increase Km) or noncompetitive (decrease Vmax).</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Run enzyme reactions at varied substrate concentrations</li><li>Measure initial reaction rates and plot Michaelis-Menten curve</li><li>Construct Lineweaver-Burk plot to determine Km and Vmax</li><li>Add inhibitors and classify their type based on kinetic changes</li><li>Analyze how environmental factors affect enzyme activity</li></ol>`,
              },
              simulation: {
                title: "Simulation: Enzyme Kinetics",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="enzyme-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="substrate-concentration" class="font-medium">Substrate Concentration (<span id="substrate-val">50</span> mM)</label><input type="range" id="substrate-concentration" min="1" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="enzyme-concentration" class="font-medium">Enzyme Concentration (<span id="enzyme-val">10</span> μM)</label><input type="range" id="enzyme-concentration" min="1" max="50" value="10" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="enzyme-temperature" class="font-medium">Temperature (<span id="temp-val">37</span>°C)</label><input type="range" id="enzyme-temperature" min="0" max="60" value="37" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="ph-level" class="font-medium">pH Level (<span id="ph-val">7.0</span>)</label><input type="range" id="ph-level" min="3" max="10" step="0.1" value="7.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Reaction Rate:</strong> <span id="reaction-rate" class="font-semibold">0.000</span> mM/s</p><p><strong>Michaelis Constant:</strong> <span id="michaelis-constant" class="font-semibold">10.0</span> mM</p><div class="flex gap-2 pt-2"><button id="start-enzyme" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start</button><button id="stop-enzyme" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button></div></div></div></div></div>`,
              },
            },
          },
          "genetics-mendelian-crosses": {
            title: "Genetics: Mendelian Crosses & Punnett Interactive",
            description:
              "Simulate monohybrid and dihybrid crosses, show genotypes/phenotypes across generations.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-teal-400"><path d="M16 3h5v5"/><path d="M8 3H3v5"/><path d="M12 22v-8"/><path d="m16 3-4 4-4-4"/><path d="m8 21 4-4 4 4"/><path d="M3 11c0 3.5 2 6 6 6s6-2.5 6-6"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand principles of dominance and segregation</li><li>Calculate genotypic and phenotypic probabilities</li><li>Construct and interpret Punnett squares</li><li>Analyze inheritance patterns in pedigrees</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Mendelian genetics follows three principles: dominance (some alleles mask others), segregation (alleles separate during gamete formation), and independent assortment (genes for different traits segregate independently).</p><p>Punnett squares predict offspring genotypes from parental genotypes. Pedigree analysis tracks inheritance patterns across generations in families.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Select parental genotypes for monohybrid or dihybrid crosses</li><li>Simulate offspring generation and analyze genotype ratios</li><li>Construct Punnett squares and compare with experimental results</li><li>Analyze pedigree charts to determine inheritance patterns</li><li>Investigate deviations from expected ratios (e.g., linkage)</li></ol>`,
              },
              simulation: {
                title: "Simulation: Genetic Crosses",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="genetics-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="parent1-genotype" class="font-medium">Parent 1 Genotype</label><select id="parent1-genotype" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="AA">AA (Homozygous Dominant)</option><option value="Aa">Aa (Heterozygous)</option><option value="aa">aa (Homozygous Recessive)</option></select></div><div><label for="parent2-genotype" class="font-medium">Parent 2 Genotype</label><select id="parent2-genotype" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="AA">AA (Homozygous Dominant)</option><option value="Aa">Aa (Heterozygous)</option><option value="aa">aa (Homozygous Recessive)</option></select></div></div><div class="space-y-4"><div><label for="trait-type" class="font-medium">Trait Type</label><select id="trait-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="dominant">Complete Dominance</option><option value="recessive">Recessive</option></select></div><div class="flex gap-2 pt-6"><button id="simulate-cross" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Simulate Cross</button></div></div></div></div>`,
              },
            },
          },
          "microbiology-virtual-culture": {
            title: "Microbiology: Virtual Culture & Antibiotic Sensitivity",
            description:
              "Simulate bacterial growth curves, plate streaking virtually, test antibiotic zones of inhibition.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-teal-400"><circle cx="12" cy="8" r="7"/><path d="M8.21 13.89 7 23l5-3 5 3-1.21-9.12"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand bacterial growth phases and kinetics</li><li>Practice aseptic technique concepts</li><li>Evaluate antibiotic efficacy through zone of inhibition</li><li>Determine minimum inhibitory concentrations (MIC)</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Bacterial growth follows four phases: lag (adaptation), log (exponential growth), stationary (nutrient depletion), and death (decline). Growth curves plot cell number vs time.</p><p>Antibiotic sensitivity testing measures zones of inhibition around antibiotic disks. The minimum inhibitory concentration (MIC) is the lowest antibiotic concentration that prevents visible growth.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Inoculate virtual culture plates using proper technique</li><li>Monitor bacterial growth curves under different conditions</li><li>Apply antibiotic disks and measure zones of inhibition</li><li>Determine MIC values for different antibiotics</li><li>Interpret results and recommend appropriate treatments</li></ol>`,
              },
              simulation: {
                title: "Simulation: Microbial Culture",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="microbiology-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="nutrient-level" class="font-medium">Nutrient Level (<span id="nutrient-val">50</span>%)</label><input type="range" id="nutrient-level" min="10" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="culture-temperature" class="font-medium">Temperature (<span id="culture-temp-val">37</span>°C)</label><input type="range" id="culture-temperature" min="20" max="45" value="37" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Culture Time:</strong> <span id="culture-time" class="font-semibold">0.0</span> hours</p><p><strong>Bacteria Count:</strong> <span id="bacteria-count" class="font-semibold">10</span> CFU</p><div class="flex gap-2 pt-2"><button id="start-culture" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start Culture</button><button id="stop-culture" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button></div></div></div></div></div>`,
              },
            },
          },
          "bioinformatics-dna-sequence": {
            title: "Bioinformatics: DNA Sequence Alignment & ORF Finder",
            description:
              "Upload or select sequences, find open reading frames, translate, run pairwise alignment.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-teal-400"><path d="M2 20h20"/><path d="m5 10 7-7 7 7"/><path d="M5 17v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1"/><path d="M12 4v16"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand genetic code and codon usage</li><li>Identify open reading frames in DNA sequences</li><li>Perform sequence alignment and analyze conservation</li><li>Predict protein sequences from DNA</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Bioinformatics applies computational methods to biological data. Open reading frames (ORFs) are DNA sequences that could potentially encode proteins, bounded by start and stop codons.</p><p>Sequence alignment compares DNA or protein sequences to identify conserved regions, mutations, and evolutionary relationships. The genetic code maps nucleotide triplets (codons) to amino acids.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Input DNA sequences or select from database</li><li>Identify open reading frames in all reading frames</li><li>Translate DNA sequences to protein sequences</li><li>Perform pairwise sequence alignment</li><li>Analyze sequence conservation and identify mutations</li></ol>`,
              },
              simulation: {
                title: "Simulation: Sequence Analysis",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="bioinformatics-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="dna-sequence" class="font-medium">DNA Sequence</label><textarea id="dna-sequence" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white h-24" placeholder="Enter DNA sequence (e.g., ATGCCGTA...)">ATCGATCGATCG</textarea></div></div><div class="space-y-4"><div><label for="analysis-type" class="font-medium">Analysis Type</label><select id="analysis-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="gc-content">GC Content</option><option value="base-count">Base Count</option></select></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Analysis Result:</strong> <span id="analysis-result" class="font-semibold">Ready for analysis</span></p><div class="flex gap-2 pt-2"><button id="analyze-sequence" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Analyze</button></div></div></div></div></div>`,
              },
            },
          },
        },

        environmentalScience: {
          "water-quality-testing": {
            title: "Water Quality Testing Simulator",
            description:
              "Virtual sampling of water bodies with tests for pH, DO, turbidity, nitrates, and heavy metals.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-lime-400"><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M16 22h2a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3"/><path d="M5 17a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/><path d="M7 16.5 8 22l-3-1-3 1 1-5.5"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Identify key indicators of water health</li><li>Understand causes and effects of water pollution</li><li>Interpret water quality standards and guidelines</li><li>Propose appropriate remediation strategies</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Water quality assessment measures physical, chemical, and biological parameters. Key indicators include pH (acidity/alkalinity), dissolved oxygen (aquatic life support), turbidity (clarity), and nutrient levels (eutrophication risk).</p><p>Heavy metals and other contaminants can accumulate in aquatic ecosystems, posing risks to both environmental and human health. Water quality standards establish safe limits for various parameters.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Select sampling sites from the interactive map</li><li>Perform water quality tests for multiple parameters</li><li>Record and map results using the data logger</li><li>Compare results with water quality standards</li><li>Propose remediation steps based on findings</li></ol>`,
              },
              simulation: {
                title: "Simulation: Water Quality Analysis",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="waterquality-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="water-ph" class="font-medium">pH Level (<span id="ph-val">7.0</span>)</label><input type="range" id="water-ph" min="3" max="11" step="0.1" value="7.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="turbidity" class="font-medium">Turbidity (<span id="turbidity-val">10</span> NTU)</label><input type="range" id="turbidity" min="0" max="100" value="10" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="dissolved-oxygen" class="font-medium">Dissolved Oxygen (<span id="do-val">8.0</span> mg/L)</label><input type="range" id="dissolved-oxygen" min="0" max="15" step="0.1" value="8.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="water-temperature" class="font-medium">Temperature (<span id="water-temp-val">20</span>°C)</label><input type="range" id="water-temperature" min="0" max="40" value="20" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Water Quality:</strong> <span id="water-quality" class="font-semibold">Excellent</span></p><div class="flex gap-2 pt-2"><button id="test-water" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Test Water</button></div></div></div></div></div>`,
              },
            },
          },
          "carbon-cycle-climate-modeling": {
            title: "Carbon Cycle & Climate Modeling Mini-Sims",
            description:
              "Simple box-model to alter emissions, land use, and ocean uptake to see CO₂ concentration changes.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-lime-400"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand global carbon fluxes and reservoirs</li><li>Differentiate between carbon sources and sinks</li><li>Analyze climate feedback loops and their impacts</li><li>Evaluate mitigation strategies for climate change</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">The carbon cycle describes the movement of carbon between atmosphere, oceans, land, and living organisms. Key fluxes include photosynthesis, respiration, ocean absorption, and fossil fuel emissions.</p><p>Climate models simulate how changes in greenhouse gas concentrations affect global temperature. Feedback loops, such as ice-albedo feedback and permafrost methane release, can amplify or dampen climate changes.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Select emission scenarios and land use patterns</li><li>Run the carbon cycle model over specified timeframes</li><li>Analyze atmospheric CO₂ concentration and temperature changes</li><li>Compare different mitigation scenarios</li><li>Evaluate the effectiveness of various climate policies</li></ol>`,
              },
              simulation: {
                title: "Simulation: Carbon Cycle Model",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="carboncycle-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="emission-rate" class="font-medium">Emission Rate (<span id="emission-val">8</span> GtC/year)</label><input type="range" id="emission-rate" min="0" max="20" value="8" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="absorption-rate" class="font-medium">Absorption Rate (<span id="absorption-val">3</span> GtC/year)</label><input type="range" id="absorption-rate" min="0" max="10" value="3" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="deforestation-rate" class="font-medium">Deforestation (<span id="deforestation-val">2</span> GtC/year)</label><input type="range" id="deforestation-rate" min="0" max="5" value="2" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>CO₂ Level:</strong> <span id="co2-level" class="font-semibold">420</span> ppm</p><p><strong>Temperature Rise:</strong> <span id="temperature-rise" class="font-semibold">1.2</span>°C</p><div class="flex gap-2 pt-2"><button id="start-carbon-cycle" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Run Model</button><button id="stop-carbon-cycle" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button></div></div></div></div></div>`,
              },
            },
          },
          "soil-analysis-plant-growth": {
            title: "Soil Analysis & Plant Growth Under Stress",
            description:
              "Simulate soil types, nutrient levels, moisture; grow virtual plants to observe effects.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-lime-400"><path d="M12 2v8"/><path d="m4.93 10.93 1.41 1.41"/><path d="M2 18h2"/><path d="M20 18h2"/><path d="m19.07 10.93-1.41 1.41"/><path d="M22 22H2"/><path d="m8 6 4-4 4 4"/><path d="M16 18a4 4 0 0 0-8 0"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand soil nutrient cycles and their importance</li><li>Analyze plant stress physiology under different conditions</li><li>Learn principles of sustainable agriculture</li><li>Evaluate soil management practices for crop production</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Soil quality affects plant growth through physical structure, nutrient availability, and water retention. Key nutrients include nitrogen, phosphorus, and potassium, each serving specific functions in plant metabolism.</p><p>Plant stress responses vary by stress type: drought triggers stomatal closure, nutrient deficiency limits growth, and soil compaction restricts root development. Sustainable practices maintain soil health while maximizing productivity.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Configure soil parameters including type, nutrients, and moisture</li><li>Plant virtual seeds and monitor growth under different conditions</li><li>Apply stressors like drought, nutrient deficiency, or compaction</li><li>Measure plant responses and growth metrics</li><li>Recommend soil management strategies for optimal growth</li></ol>`,
              },
              simulation: {
                title: "Simulation: Soil & Plant Analysis",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="soilanalysis-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="soil-ph" class="font-medium">Soil pH (<span id="soil-ph-val">6.5</span>)</label><input type="range" id="soil-ph" min="4" max="9" step="0.1" value="6.5" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="nitrogen-level" class="font-medium">Nitrogen Level (<span id="nitrogen-val">50</span>%)</label><input type="range" id="nitrogen-level" min="0" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="moisture-level" class="font-medium">Moisture Level (<span id="moisture-val">60</span>%)</label><input type="range" id="moisture-level" min="0" max="100" value="60" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="organic-matter" class="font-medium">Organic Matter (<span id="organic-val">30</span>%)</label><input type="range" id="organic-matter" min="0" max="100" value="30" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Plant Growth:</strong> <span id="plant-growth" class="font-semibold">75</span>%</p><div class="flex gap-2 pt-2"><button id="grow-plants" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Grow Plants</button></div></div></div></div></div>`,
              },
            },
          },
          "renewable-energy-site-analysis": {
            title: "Renewable Energy: Wind & Solar Site Analysis",
            description:
              "Simulate siting with wind speed/time series and solar irradiance datasets; compute expected output.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-lime-400"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand capacity factor and its importance in renewable energy</li><li>Evaluate site suitability for different renewable technologies</li><li>Perform basic economic analysis of renewable energy projects</li><li>Compare energy output from different renewable sources</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Renewable energy site analysis considers resource availability (solar irradiance, wind speed), land use, and infrastructure. Capacity factor measures actual output compared to maximum possible output.</p><p>Solar energy potential depends on latitude, climate, and orientation. Wind energy potential increases with wind speed cubed, making site selection critical. Economic viability considers installation costs, maintenance, and energy production.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Select potential sites using geographic and climate data</li><li>Run year-long simulations of energy production</li><li>Calculate capacity factors and expected energy output</li><li>Perform simple economic analysis including payback periods</li><li>Compare different renewable energy options for the same site</li></ol>`,
              },
              simulation: {
                title: "Simulation: Renewable Energy Analysis",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="renewableenergy-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="solar-capacity" class="font-medium">Solar Capacity (<span id="solar-val">100</span> MW)</label><input type="range" id="solar-capacity" min="10" max="500" value="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="wind-capacity" class="font-medium">Wind Capacity (<span id="wind-val">50</span> MW)</label><input type="range" id="wind-capacity" min="10" max="200" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="hydro-capacity" class="font-medium">Hydro Capacity (<span id="hydro-val">75</span> MW)</label><input type="range" id="hydro-capacity" min="10" max="300" value="75" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="energy-demand" class="font-medium">Energy Demand (<span id="demand-val">200</span> MW)</label><input type="range" id="energy-demand" min="50" max="500" value="200" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Energy Output:</strong> <span id="energy-output" class="font-semibold">150</span> MW</p><p><strong>Demand Coverage:</strong> <span id="demand-coverage" class="font-semibold">75</span>%</p><div class="flex gap-2 pt-2"><button id="calculate-energy" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Calculate</button></div></div></div></div></div>`,
              },
            },
          },
          "ecological-population-dynamics": {
            title: "Ecological Population Dynamics (Predator-Prey)",
            description:
              "Lotka-Volterra style sim where students alter carrying capacity, hunting pressure, disease.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-lime-400"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand population cycles and their causes</li><li>Analyze ecosystem stability and resilience</li><li>Evaluate the effects of carrying capacity on populations</li><li>Model predator-prey interactions mathematically</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">The Lotka-Volterra model describes predator-prey dynamics through coupled differential equations. Prey populations grow exponentially in the absence of predators, while predator populations decline without prey.</p><p>Carrying capacity represents the maximum population size an environment can sustain. Population cycles emerge from time-delayed feedback between predators and prey. External factors like disease and hunting pressure can disrupt these natural cycles.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Set initial population parameters for predators and prey</li><li>Run multi-year simulations of population dynamics</li><li>Analyze population oscillations and equilibrium points</li><li>Introduce external factors like disease or hunting pressure</li><li>Explain causes of population collapse or stability in different scenarios</li></ol>`,
              },
              simulation: {
                title: "Simulation: Population Dynamics",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="population-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="prey-population" class="font-medium">Prey Population (<span id="prey-val">100</span>)</label><input type="range" id="prey-population" min="10" max="500" value="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="predator-population" class="font-medium">Predator Population (<span id="predator-val">20</span>)</label><input type="range" id="predator-population" min="5" max="100" value="20" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="food-availability" class="font-medium">Food Availability (<span id="food-val">50</span>%)</label><input type="range" id="food-availability" min="10" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Simulation Time:</strong> <span id="simulation-time" class="font-semibold">0</span> years</p><div class="flex gap-2 pt-2"><button id="start-population" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start Simulation</button><button id="stop-population" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button></div></div></div></div></div>`,
              },
            },
          },
        },

        electronicsIot: {
          "breadboard-circuit-builder": {
            title: "Breadboard Circuit Builder (Digital + Analog)",
            description:
              "Virtual breadboard to assemble circuits with LEDs, resistors, transistors, and ICs.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-orange-400"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Develop practical circuit wiring skills</li><li>Apply Ohm\'s law to circuit analysis</li><li>Understand basic transistor switching operations</li><li>Troubleshoot and debug electronic circuits</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Breadboards provide a platform for prototyping electronic circuits without soldering. Internal connections allow components to be easily inserted and rearranged.</p><p>Ohm\'s law (V = IR) relates voltage, current, and resistance. Transistors act as electronic switches or amplifiers, controlling current flow based on input signals. Integrated circuits (ICs) contain multiple electronic components in a single package.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Build circuits from schematics using drag-and-drop components</li><li>Test circuit nodes with virtual multimeter and oscilloscope</li><li>Debug circuits by identifying and correcting wiring errors</li><li>Measure voltages and currents at different points in the circuit</li><li>Verify circuit operation matches theoretical predictions</li></ol>`,
              },
              simulation: {
                title: "Simulation: Circuit Builder",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="breadboard-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="circuit-component" class="font-medium">Add Component</label><select id="circuit-component" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="resistor">Resistor</option><option value="led">LED</option><option value="battery">Battery</option><option value="capacitor">Capacitor</option></select></div><div class="flex gap-2"><button id="add-resistor" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Add Resistor</button><button id="add-led" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Add LED</button></div><div class="flex gap-2"><button id="add-battery" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Add Battery</button><button id="add-capacitor" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Add Capacitor</button></div></div><div class="space-y-4"><div><label for="circuit-voltage" class="font-medium">Circuit Voltage (<span id="voltage-val">9</span> V)</label><input type="range" id="circuit-voltage" min="1" max="24" value="9" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Circuit Current:</strong> <span id="circuit-current" class="font-semibold">0.000</span> A</p><p><strong>Circuit Status:</strong> <span id="circuit-status" class="font-semibold">Open Circuit</span></p><div class="flex gap-2 pt-2"><button id="clear-circuit" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Clear Circuit</button></div></div></div></div></div>`,
              },
            },
          },
          "microcontroller-programming": {
            title: "Microcontroller Programming: Blink → Sensor Read",
            description:
              "Virtual MCU (Arduino-like) with code editor, serial monitor, and sensor models (temp, light).",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-orange-400"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"/><rect x="9" y="9" width="6" height="6"/><line x1="9" y1="1" x2="9" y2="4"/><line x1="15" y1="1" x2="15" y2="4"/><line x1="9" y1="20" x2="9" y2="23"/><line x1="15" y1="20" x2="15" y2="23"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Program embedded I/O operations</li><li>Read analog signals using ADC</li><li>Implement PWM control for output devices</li><li>Handle simple interrupts in embedded systems</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Microcontrollers are small computers on a single integrated circuit containing a processor, memory, and programmable input/output peripherals. They read sensors, control actuators, and execute programmed instructions.</p><p>Analog-to-digital converters (ADC) convert continuous analog signals to discrete digital values. Pulse-width modulation (PWM) creates analog-like behavior using digital signals. Interrupts allow immediate response to external events.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Write code to read sensors and control output devices</li><li>Upload code to the virtual microcontroller</li><li>Monitor serial output and sensor readings in real-time</li><li>Implement PWM control for LEDs or motors</li><li>Add interrupt handling for responsive system behavior</li></ol>`,
              },
              simulation: {
                title: "Simulation: Microcontroller Programming",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="microcontroller-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="arduino-code" class="font-medium">Arduino Code</label><textarea id="arduino-code" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white h-32" placeholder="void setup() {&#10;  // Setup code here&#10;}&#10;&#10;void loop() {&#10;  // Main code here&#10;}">void setup() {
  pinMode(13, OUTPUT);
}

void loop() {
  digitalWrite(13, HIGH);
  delay(1000);
  digitalWrite(13, LOW);
  delay(1000);
}</textarea></div></div><div class="space-y-4"><div><label for="sensor-type" class="font-medium">Sensor Type</label><select id="sensor-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="temperature">Temperature</option><option value="light">Light</option><option value="motion">Motion</option></select></div><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Program Output:</strong> <span id="program-output" class="font-semibold">Ready</span></p><div class="flex gap-2 pt-2"><button id="upload-code" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Upload Code</button></div></div></div></div></div>`,
              },
            },
          },
          "signal-processing-adc-fft": {
            title: "Signal Processing: ADC Sampling & FFT",
            description:
              "Feed analog signals into virtual ADC, sample at variable rates, perform FFT & filtering.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-orange-400"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand and apply the Nyquist sampling theorem</li><li>Identify and prevent aliasing in sampled signals</li><li>Implement basic digital filtering techniques</li><li>Analyze signals in frequency domain using FFT</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">The Nyquist theorem states that a signal must be sampled at least twice its highest frequency component to avoid aliasing. Aliasing occurs when high-frequency components appear as lower frequencies in the sampled signal.</p><p>The Fast Fourier Transform (FFT) converts signals from time domain to frequency domain, revealing their spectral components. Digital filters remove unwanted frequency components while preserving desired signals.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Generate composite signals with multiple frequency components</li><li>Sample signals at different rates to demonstrate aliasing</li><li>Visualize signal spectrum using FFT analysis</li><li>Design and apply digital filters to remove noise</li><li>Compare filtered and unfiltered signals in both domains</li></ol>`,
              },
              simulation: {
                title: "Simulation: Signal Processing",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><div class="grid grid-cols-1 lg:grid-cols-2 gap-4"><div class="w-full h-48 bg-gray-900 rounded-md border border-slate-700"><canvas id="signal-time-canvas"></canvas></div><div class="w-full h-48 bg-gray-900 rounded-md border border-slate-700"><canvas id="signal-freq-canvas"></canvas></div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="signal-type" class="font-medium">Signal Type</label><select id="signal-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="sine">Sine Wave</option><option value="square">Square Wave</option><option value="triangle">Triangle Wave</option><option value="noise">Noise</option></select></div><div><label for="signal-frequency" class="font-medium">Frequency (<span id="freq-val">1.0</span> Hz)</label><input type="range" id="signal-frequency" min="0.1" max="10" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="signal-amplitude" class="font-medium">Amplitude (<span id="amp-val">1.0</span>)</label><input type="range" id="signal-amplitude" min="0.1" max="2.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div><label for="noise-level" class="font-medium">Noise Level (<span id="noise-val">0.0</span>)</label><input type="range" id="noise-level" min="0" max="1.0" step="0.1" value="0.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div class="flex gap-2 pt-6"><button id="process-signal" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Process Signal</button></div></div></div></div>`,
              },
            },
          },
          "wireless-comm-lora-wifi": {
            title: "Wireless Comm: LoRa/Wi-Fi Packet Exchange Simulator",
            description:
              "Simulate endpoints exchanging packets with configurable distance, interference, and data rates.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-orange-400"><path d="M5 16V9h14V2H5l14 14h-7m-7 0 7 7m-7-7h7"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand physical and MAC layer basics</li><li>Analyze causes of packet loss in wireless networks</li><li>Evaluate throughput vs range tradeoffs</li><li>Optimize parameters for reliable communication</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">Wireless communication involves transmitting data through radio waves. Different protocols (Wi-Fi, Bluetooth, LoRa) optimize for different tradeoffs between range, data rate, and power consumption.</p><p>Packet loss occurs due to distance, interference, and collisions. The physical layer handles signal transmission, while the MAC layer manages access to the shared medium. Throughput decreases with distance and interference.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Deploy wireless nodes at different distances</li><li>Send data traffic between nodes and measure performance</li><li>Introduce interference and observe effects on packet delivery</li><li>Measure latency and throughput under different conditions</li><li>Optimize communication parameters for specific requirements</li></ol>`,
              },
              simulation: {
                title: "Simulation: Wireless Communication",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="wireless-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="protocol-type" class="font-medium">Protocol Type</label><select id="protocol-type" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white"><option value="wifi">Wi-Fi</option><option value="bluetooth">Bluetooth</option><option value="lora">LoRa</option><option value="zigbee">Zigbee</option></select></div><div><label for="transmission-distance" class="font-medium">Distance (<span id="distance-val">50</span> m)</label><input type="range" id="transmission-distance" min="1" max="200" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="transmission-power" class="font-medium">Transmit Power (<span id="power-val">100</span>%)</label><input type="range" id="transmission-power" min="10" max="100" value="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Data Rate:</strong> <span id="data-rate" class="font-semibold">54.0</span> Mbps</p><p><strong>Effective Range:</strong> <span id="effective-range" class="font-semibold">50</span> m</p><div class="flex gap-2 pt-2"><button id="send-data" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Send Data</button></div></div></div></div></div>`,
              },
            },
          },
          "iot-data-pipeline": {
            title: "IoT Data Pipeline: Sensor → Cloud → Dashboard",
            description:
              "Simulate sensor streams, virtual MQTT broker, simple backend to store/visualize.",
            icon: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-orange-400"><path d="m8 3 4 8 5-5 5 15H2L8 3z"/></svg>`,
            sections: {
              aim: {
                title: "Learning Objectives",
                content: `<ul class="list-disc list-inside space-y-2 text-slate-300"><li>Understand IoT telemetry data collection</li><li>Implement message queuing with MQTT/REST</li><li>Create data visualization dashboards</li><li>Analyze IoT system failure modes and reliability</li></ul>`,
              },
              theory: {
                title: "Theory",
                content: `<div class="text-slate-300"><p class="mb-4">IoT systems collect data from sensors, transmit it to cloud platforms, and present it through dashboards. MQTT is a lightweight publish-subscribe messaging protocol ideal for IoT applications.</p><p>Data pipelines involve ingestion (collecting data), processing (transforming data), storage (saving data), and visualization (displaying data). System reliability depends on network connectivity, data integrity, and fault tolerance.</p></div>`,
              },
              procedure: {
                title: "Procedure",
                content: `<ol class="list-decimal list-inside space-y-2 text-slate-300"><li>Configure virtual sensors and data streams</li><li>Set up message queuing for telemetry data</li><li>Push data to cloud storage and processing</li><li>Create dashboards for live and historical data visualization</li><li>Implement alert thresholds and monitor system performance</li></ol>`,
              },
              simulation: {
                title: "Simulation: IoT Data Pipeline",
                content: `<div class="glass-card shadow-lg p-4 sm:p-6"><canvas id="iot-canvas" class="w-full h-64 md:h-96 bg-gray-900 rounded-md border border-slate-700"></canvas><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 text-sm text-slate-300"><div class="space-y-4"><div><label for="sensor-rate" class="font-medium">Sensor Data Rate (<span id="sensor-val">10</span> Hz)</label><input type="range" id="sensor-rate" min="1" max="100" value="10" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="processing-speed" class="font-medium">Processing Speed (<span id="processing-val">80</span>%)</label><input type="range" id="processing-speed" min="10" max="100" value="80" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div><div><label for="storage-capacity" class="font-medium">Storage Capacity (<span id="storage-val">90</span>%)</label><input type="range" id="storage-capacity" min="10" max="100" value="90" class="w-full h-2 rounded-lg appearance-none cursor-pointer slider-thumb"></div></div><div class="space-y-4"><div class="bg-slate-900 rounded-lg p-4 space-y-2 border border-slate-700"><p><strong>Data Processed:</strong> <span id="data-processed" class="font-semibold">0</span> points</p><p><strong>Pipeline Efficiency:</strong> <span id="pipeline-efficiency" class="font-semibold">72</span>%</p><div class="flex gap-2 pt-2"><button id="start-pipeline" class="w-full sim-button text-white font-semibold py-2 px-4 rounded-lg">Start Pipeline</button><button id="stop-pipeline" class="w-full bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-700">Stop</button></div></div></div></div></div>`,
              },
            },
          },
        },
      };

      // --- APP STATE AND ROUTING ---
      const appState = {
        currentPage: "home",
        currentSubject: null,
        currentExperimentId: null,
        currentSection: "aim",
        lastExperimentId: null,
      };

      // This object will hold references to active simulation instances for cleanup
      const simulationInstances = {};

      // --- DOM ELEMENTS ---
      const homePage = document.getElementById("home-page");
      const subjectPage = document.getElementById("subject-page");
      const experimentPage = document.getElementById("experiment-page");
      const experimentGrid = document.getElementById("experiment-grid");
      const backToHomeFromSubjectBtn = document.getElementById(
        "back-to-home-from-subject"
      );
      const backToSubjectBtn = document.getElementById("back-to-subject");
      const experimentTitleSidebar = document.getElementById(
        "experiment-title-sidebar"
      );
      const experimentNav = document.getElementById("experiment-nav");
      const experimentContent = document.getElementById("experiment-content");
      const subjectTitle = document.getElementById("subject-title");

      const subjectSelectors = {
        physics: {
          btn: document.getElementById("select-physics"),
          name: "Physics",
        },
        chemistry: {
          btn: document.getElementById("select-chemistry"),
          name: "Chemistry",
        },
        biology: {
          btn: document.getElementById("select-biology"),
          name: "Biology",
        },
        environmentalScience: {
          btn: document.getElementById("select-environmentalScience"),
          name: "Environmental Science",
        },
        electronicsIot: {
          btn: document.getElementById("select-electronicsIot"),
          name: "Electronics & IoT",
        },
      };

      const subjectGradients = {
        physics: "from-blue-400 to-sky-400",
        chemistry: "from-emerald-400 to-green-400",
        biology: "from-teal-400 to-cyan-400",
        environmentalScience: "from-lime-400 to-yellow-400",
        electronicsIot: "from-orange-400 to-red-400",
      };

      // --- PAGE NAVIGATION LOGIC ---
      function navigateTo(
        page,
        subject = null,
        experimentId = null,
        section = "aim"
      ) {
        cleanupCurrentSimulation(); // Clean up before navigating

        appState.currentPage = page;
        appState.currentSubject = subject;
        appState.currentExperimentId = experimentId;
        appState.currentSection = section;
        renderApp();
        window.scrollTo(0, 0); // Scroll to top on page change
      }

      function renderApp() {
        homePage.classList.remove("active");
        subjectPage.classList.remove("active");
        experimentPage.classList.remove("active");

        if (appState.currentPage === "home") {
          homePage.classList.add("active");
        } else if (appState.currentPage === "subject") {
          renderSubjectPage();
          subjectPage.classList.add("active");
        } else if (appState.currentPage === "experiment") {
          renderExperimentPage();
          experimentPage.classList.add("active");
        }
      }

      // --- RENDERING FUNCTIONS ---
      function renderSubjectPage() {
        const subject = appState.currentSubject;
        if (!subject) return;

        subjectTitle.textContent = `${subjectSelectors[subject].name} Experiments`;
        subjectTitle.className = `text-4xl md:text-6xl font-bold text-transparent bg-clip-text bg-gradient-to-r ${subjectGradients[subject]}`;
        createExperimentCards(subject);
      }

      function createExperimentCards(subject) {
        experimentGrid.innerHTML = "";
        const subjectExperiments = experiments[subject];
        for (const id in subjectExperiments) {
          const exp = subjectExperiments[id];
          const card = document.createElement("div");
          card.className =
            "glass-card p-6 rounded-xl shadow-lg hover:shadow-2xl hover:-translate-y-2 transition-all duration-300 cursor-pointer";
          card.dataset.experimentId = id;
          card.dataset.subject = subject;

          const iconColorClass =
            {
              physics: "text-blue-400",
              chemistry: "text-emerald-400",
              biology: "text-teal-400",
              environmentalScience: "text-lime-400",
              electronicsIot: "text-orange-400",
            }[subject] || "text-slate-400";

          card.innerHTML = `
            <div class="flex items-start gap-4">
                ${exp.icon.replace(
                  /class="[^"]*"/,
                  `class="${iconColorClass}"`
                )}
                <div>
                    <h3 class="text-xl font-bold text-white">${exp.title}</h3>
                    <p class="text-slate-400 mt-1">${exp.description}</p>
                </div>
            </div>
        `;
          experimentGrid.appendChild(card);
        }
      }

      function renderExperimentPage() {
        const exp =
          experiments[appState.currentSubject][appState.currentExperimentId];
        if (!exp) return;

        experimentTitleSidebar.textContent = exp.title;
        experimentNav.innerHTML = "";
        for (const sectionId in exp.sections) {
          const section = exp.sections[sectionId];
          const link = document.createElement("a");
          link.href = "#";
          link.dataset.sectionId = sectionId;
          link.textContent = section.title.split(":")[0];
          link.className = `block px-4 py-2 rounded-lg text-sm font-medium text-slate-300 sidebar-link ${
            appState.currentSubject
          } ${sectionId === appState.currentSection ? "active" : ""}`;
          experimentNav.appendChild(link);
        }
        renderExperimentSection();
      }

      function renderExperimentSection() {
        cleanupCurrentSimulation();
        const section =
          experiments[appState.currentSubject][appState.currentExperimentId]
            .sections[appState.currentSection];
        if (!section) return;

        const accentColorClass =
          {
            physics: "text-blue-400",
            chemistry: "text-emerald-400",
            biology: "text-teal-400",
            environmentalScience: "text-lime-400",
            electronicsIot: "text-orange-400",
          }[appState.currentSubject] || "text-slate-400";

        const content = section.content
          .replace(/slider-thumb/g, `slider-thumb ${appState.currentSubject}`)
          .replace(/sim-button/g, `sim-button ${appState.currentSubject}`)
          .replace(
            /text-blue-400|text-emerald-400|text-teal-400|text-lime-400|text-orange-400/g,
            accentColorClass
          );

        experimentContent.innerHTML = `
        <h2 class="text-3xl font-bold mb-6 text-white border-b border-slate-700 pb-3">${section.title}</h2>
        <div class="prose max-w-none">${content}</div>
    `;

        if (appState.currentSection === "simulation") {
          setTimeout(() => initSimulation(appState.currentExperimentId), 50);
        }
      }

      // --- EVENT LISTENERS ---
      document.addEventListener("DOMContentLoaded", renderApp);

      Object.keys(subjectSelectors).forEach((subjectKey) => {
        subjectSelectors[subjectKey].btn.addEventListener("click", () =>
          navigateTo("subject", subjectKey)
        );
      });

      experimentGrid.addEventListener("click", (e) => {
        const card = e.target.closest("[data-experiment-id]");
        if (card) {
          navigateTo(
            "experiment",
            card.dataset.subject,
            card.dataset.experimentId,
            "aim"
          );
        }
      });

      backToHomeFromSubjectBtn.addEventListener("click", () =>
        navigateTo("home")
      );
      backToSubjectBtn.addEventListener("click", () =>
        navigateTo("subject", appState.currentSubject)
      );

      experimentNav.addEventListener("click", (e) => {
        e.preventDefault();
        const link = e.target.closest("[data-section-id]");
        if (link) {
          appState.currentSection = link.dataset.sectionId;
          renderExperimentPage(); // Re-render to handle simulation init/cleanup
        }
      });

      // --- SIMULATIONS LOGIC ---

      // Master cleanup function
      function cleanupCurrentSimulation() {
        const lastId = appState.lastExperimentId;
        if (lastId && simulationInstances[lastId]) {
          const instance = simulationInstances[lastId];
          if (instance.animationFrameId) {
            cancelAnimationFrame(instance.animationFrameId);
          }
          if (instance.resizeListener) {
            window.removeEventListener("resize", instance.resizeListener);
          }
          // Add any other specific cleanup logic here
          delete simulationInstances[lastId];
        }
        appState.lastExperimentId = null;
      }

      // Master simulation initializer
      function initSimulation(experimentId) {
        cleanupCurrentSimulation(); // Ensure previous sim is cleaned
        appState.lastExperimentId = experimentId;
        simulationInstances[experimentId] = {}; // Create a namespace for the new sim

        const allSimulations = {
          ...experiments.physics,
          ...experiments.chemistry,
          ...experiments.biology,
          ...experiments.environmentalScience,
          ...experiments.electronicsIot,
        };
        if (allSimulations[experimentId]) {
          switch (experimentId) {
            // Physics
            case "projectile-motion":
              initProjectileMotion();
              break;
            case "simple-harmonic-motion":
              initSimpleHarmonicMotion();
              break;
            case "electric-circuits":
              initElectricCircuits();
              break;
            case "optics-ray-tracing":
              initOpticsRayTracing();
              break;
            case "energy-pendulum":
              initEnergyPendulum();
              break;
            // Chemistry
            case "virtual-titration":
              initVirtualTitration();
              break;
            case "chemical-kinetics":
              initChemicalKinetics();
              break;
            case "electrochemistry-galvanic-cells":
              initElectrochemistry();
              break;
            case "equilibrium-le-chatelier":
              initEquilibrium();
              break;
            case "molecular-modeling":
              initMolecularModeling();
              break;
            // Biology
            case "cell-structure-explorer":
              initCellExplorer();
              break;
            case "enzyme-kinetics":
              initEnzymeKinetics();
              break;
            case "genetics-mendelian-crosses":
              initGenetics();
              break;
            case "microbiology-virtual-culture":
              initMicrobiology();
              break;
            case "bioinformatics-dna-sequence":
              initBioinformatics();
              break;
            // Environmental Science
            case "water-quality-testing":
              initWaterQuality();
              break;
            case "carbon-cycle-climate-modeling":
              initCarbonCycle();
              break;
            case "soil-analysis-plant-growth":
              initSoilAnalysis();
              break;
            case "renewable-energy-site-analysis":
              initRenewableEnergy();
              break;
            case "ecological-population-dynamics":
              initPopulationDynamics();
              break;
            // Electronics & IoT
            case "breadboard-circuit-builder":
              initBreadboard();
              break;
            case "microcontroller-programming":
              initMicrocontroller();
              break;
            case "signal-processing-adc-fft":
              initSignalProcessing();
              break;
            case "wireless-comm-lora-wifi":
              initWirelessComm();
              break;
            case "iot-data-pipeline":
              initIotPipeline();
              break;
          }
        }
      }

      // --- START PHYSICS SIMULATIONS ---

      // 1. Projectile Motion Simulation
      function initProjectileMotion() {
        const canvas = document.getElementById("projectile-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        const velocitySlider = document.getElementById("velocity");
        const angleSlider = document.getElementById("angle");
        const velocityVal = document.getElementById("velocity-val");
        const angleVal = document.getElementById("angle-val");
        const fireBtn = document.getElementById("fire-btn");
        const resetBtn = document.getElementById("reset-btn");
        const maxHeightEl = document.getElementById("max-height");
        const rangeEl = document.getElementById("range");
        const airResistanceCheck = document.getElementById("air-resistance");

        let projectiles = [];
        const g = 9.81;
        let scale = 5;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          scale = canvas.width / 200; // Adjust scale based on width
          drawScene();
        }

        function drawGrid() {
          ctx.strokeStyle = "rgba(100, 116, 139, 0.3)";
          ctx.lineWidth = 1;
          const gridSize = 50;
          for (let x = 0; x < canvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
          }
          for (let y = 0; y < canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          }
        }

        function drawScene() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawGrid();
          const groundHeight = 30;
          ctx.fillStyle = "#0f766e";
          ctx.fillRect(
            0,
            canvas.height - groundHeight,
            canvas.width,
            groundHeight
          );

          const angle = (-parseFloat(angleSlider.value) * Math.PI) / 180;
          const cannonBaseX = 40;
          const cannonBaseY = canvas.height - groundHeight;

          ctx.save();
          ctx.translate(cannonBaseX, cannonBaseY);
          ctx.rotate(angle);
          ctx.fillStyle = "#94a3b8";
          ctx.beginPath();
          const cannonLength = 60;
          ctx.moveTo(0, -10);
          ctx.lineTo(cannonLength, -6);
          ctx.lineTo(cannonLength, 6);
          ctx.lineTo(0, 10);
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          ctx.fillStyle = "#475569";
          ctx.beginPath();
          ctx.arc(cannonBaseX, cannonBaseY, 20, 0, 2 * Math.PI);
          ctx.fill();
        }

        function updateUI() {
          if (!velocityVal) return;
          velocityVal.textContent = velocitySlider.value;
          angleVal.textContent = angleSlider.value;
          drawScene();
        }

        function fire() {
          const v0 = parseFloat(velocitySlider.value);
          const angleRad = (parseFloat(angleSlider.value) * Math.PI) / 180;
          const useAirResistance = airResistanceCheck.checked;
          const color = `hsl(${Math.random() * 360}, 90%, 70%)`;

          const startX = 40 + 60 * Math.cos(angleRad);
          const startY = canvas.height - 30 - 60 * Math.sin(angleRad);

          const createProjectile = (isGhost, resistance) => ({
            x: startX,
            y: startY,
            vx: v0 * Math.cos(angleRad),
            vy: -v0 * Math.sin(angleRad),
            path: [{ x: startX, y: startY }],
            color: isGhost ? "rgba(255,255,255,0.3)" : color,
            airResistance: resistance,
            isGhost,
            maxHeight: 0,
            range: 0,
            landed: false,
          });

          projectiles = [
            createProjectile(true, false), // Ghost projectile (no resistance)
            createProjectile(false, useAirResistance), // Main projectile
          ];

          animate();
        }

        function animate() {
          drawScene();
          let stillAnimating = false;

          projectiles.forEach((p) => {
            if (!p.landed && p.y <= canvas.height - 30) {
              stillAnimating = true;
              const dt = 0.1;
              p.vy += (g / scale) * dt;
              if (p.airResistance) {
                const drag = 0.01;
                p.vx -= p.vx * drag * dt;
                p.vy -= p.vy * drag * dt;
              }
              p.x += p.vx * dt;
              p.y += p.vy * dt;
              p.path.push({ x: p.x, y: p.y });

              const currentHeight = (canvas.height - 30 - p.y) / scale;
              if (currentHeight > p.maxHeight) p.maxHeight = currentHeight;

              if (p.y > canvas.height - 30) {
                p.y = canvas.height - 30;
                p.landed = true;
                p.range = (p.x - 40) / scale;
                if (!p.isGhost) {
                  maxHeightEl.textContent = p.maxHeight.toFixed(2);
                  rangeEl.textContent = p.range.toFixed(2);
                }
              }
            }

            // Draw path
            ctx.beginPath();
            ctx.strokeStyle = p.color;
            ctx.lineWidth = p.isGhost ? 2 : 3;
            ctx.setLineDash(p.isGhost ? [5, 5] : []);
            ctx.moveTo(p.path[0].x, p.path[0].y);
            p.path.forEach((pt) => ctx.lineTo(pt.x, pt.y));
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw projectile
            if (!p.isGhost) {
              ctx.beginPath();
              ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.shadowColor = p.color;
              ctx.shadowBlur = 15;
              ctx.fill();
              ctx.shadowBlur = 0;
            }
          });

          if (stillAnimating) {
            simulationInstances["projectile-motion"].animationFrameId =
              requestAnimationFrame(animate);
          }
        }

        function reset() {
          projectiles = [];
          maxHeightEl.textContent = "0.00";
          rangeEl.textContent = "0.00";
          if (simulationInstances["projectile-motion"]?.animationFrameId) {
            cancelAnimationFrame(
              simulationInstances["projectile-motion"].animationFrameId
            );
          }
          drawScene();
        }

        velocitySlider.addEventListener("input", updateUI);
        angleSlider.addEventListener("input", updateUI);
        fireBtn.addEventListener("click", fire);
        resetBtn.addEventListener("click", reset);

        const resizeListener = () => {
          resizeCanvas();
          projectiles.forEach((p) => drawScene());
        };
        window.addEventListener("resize", resizeListener);
        simulationInstances["projectile-motion"].resizeListener =
          resizeListener;

        resizeCanvas();
        updateUI();
      }

      // 2. Simple Harmonic Motion Simulation
      function initSimpleHarmonicMotion() {
        const timeCanvas = document.getElementById("shm-time-canvas");
        const freqCanvas = document.getElementById("shm-freq-canvas");
        if (!timeCanvas || !freqCanvas) return;
        const timeCtx = timeCanvas.getContext("2d");
        const freqCtx = freqCanvas.getContext("2d");

        // Controls
        const sliders = {
          k: document.getElementById("k-slider"),
          m: document.getElementById("m-slider"),
          b: document.getElementById("b-slider"),
          df: document.getElementById("df-slider"),
          da: document.getElementById("da-slider"),
        };
        const values = {
          k: document.getElementById("k-val"),
          m: document.getElementById("m-val"),
          b: document.getElementById("b-val"),
          df: document.getElementById("df-val"),
          da: document.getElementById("da-val"),
        };
        const startBtn = document.getElementById("start-shm-btn");
        const resetBtn = document.getElementById("reset-shm-btn");

        let state = {
          time: 0,
          pos: 1.5, // Initial position
          vel: 0,
          running: false,
          history: [],
          resonanceData: new Map(),
        };

        function resizeCanvases() {
          [timeCanvas, freqCanvas].forEach((canvas) => {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
          });
          drawFreqGraph(); // Redraw static graph on resize
        }

        function updateUI() {
          for (const key in sliders) {
            if (sliders[key] && values[key]) {
              values[key].textContent = parseFloat(sliders[key].value).toFixed(
                1
              );
            }
          }
        }

        function reset() {
          state.running = false;
          state.time = 0;
          state.pos = 1.5;
          state.vel = 0;
          state.history = [];
          state.resonanceData.clear();
          startBtn.textContent = "Start";
          startBtn.disabled = false;
          timeCtx.clearRect(0, 0, timeCanvas.width, timeCanvas.height);
          drawFreqGraph();
        }

        function drawTimeGraph() {
          timeCtx.clearRect(0, 0, timeCanvas.width, timeCanvas.height);
          timeCtx.strokeStyle = "rgba(100, 116, 139, 0.3)";
          timeCtx.lineWidth = 1;
          timeCtx.beginPath();
          timeCtx.moveTo(0, timeCanvas.height / 2);
          timeCtx.lineTo(timeCanvas.width, timeCanvas.height / 2);
          timeCtx.stroke();

          if (state.history.length < 2) return;

          timeCtx.beginPath();
          timeCtx.strokeStyle = "var(--accent-blue)";
          timeCtx.lineWidth = 2;

          const maxHistory = timeCanvas.width / 2;
          const relevantHistory = state.history.slice(-maxHistory);

          relevantHistory.forEach((point, i) => {
            const x = timeCanvas.width - (relevantHistory.length - 1 - i) * 2;
            const y = timeCanvas.height / 2 - point * (timeCanvas.height / 4);
            if (i === 0) timeCtx.moveTo(x, y);
            else timeCtx.lineTo(x, y);
          });
          timeCtx.stroke();
        }

        function drawFreqGraph() {
          freqCtx.clearRect(0, 0, freqCanvas.width, freqCanvas.height);
          const k = parseFloat(sliders.k.value);
          const m = parseFloat(sliders.m.value);
          const naturalFreq = Math.sqrt(k / m);

          // Draw natural frequency line
          freqCtx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          freqCtx.lineWidth = 2;
          freqCtx.setLineDash([5, 5]);
          const maxFreq = parseFloat(sliders.df.max);
          const natX = (naturalFreq / maxFreq) * freqCanvas.width;
          freqCtx.beginPath();
          freqCtx.moveTo(natX, 0);
          freqCtx.lineTo(natX, freqCanvas.height);
          freqCtx.stroke();
          freqCtx.setLineDash([]);

          // Draw resonance data points
          freqCtx.fillStyle = "var(--accent-blue)";
          state.resonanceData.forEach((amp, freq) => {
            const x = (freq / maxFreq) * freqCanvas.width;
            const y = freqCanvas.height - Math.min(amp * 40, freqCanvas.height);
            freqCtx.beginPath();
            freqCtx.arc(x, y, 3, 0, 2 * Math.PI);
            freqCtx.fill();
          });
        }

        function animate() {
          if (!state.running) return;

          const k = parseFloat(sliders.k.value);
          const m = parseFloat(sliders.m.value);
          const b = parseFloat(sliders.b.value);
          const driveFreq = parseFloat(sliders.df.value);
          const driveAmp = parseFloat(sliders.da.value);

          const dt = 0.02;

          for (let i = 0; i < 5; i++) {
            // Sub-steps for stability
            const springForce = -k * state.pos;
            const dampingForce = -b * state.vel;
            const drivingForce = driveAmp * Math.cos(driveFreq * state.time);
            const totalForce = springForce + dampingForce + drivingForce;
            const accel = totalForce / m;

            state.vel += accel * (dt / 5);
            state.pos += state.vel * (dt / 5);
            state.time += dt / 5;
          }

          state.history.push(state.pos);
          if (state.history.length > timeCanvas.width) state.history.shift();

          // Update resonance data
          if (driveAmp > 0) {
            const lastSecond = state.history.slice(-Math.floor(1 / dt));
            if (lastSecond.length > 0) {
              const maxAmp = Math.max(...lastSecond.map(Math.abs));
              state.resonanceData.set(driveFreq, maxAmp);
            }
          }

          drawTimeGraph();
          drawFreqGraph();

          simulationInstances["simple-harmonic-motion"].animationFrameId =
            requestAnimationFrame(animate);
        }

        startBtn.addEventListener("click", () => {
          state.running = !state.running;
          if (state.running) {
            startBtn.textContent = "Pause";
            animate();
          } else {
            startBtn.textContent = "Resume";
          }
        });

        resetBtn.addEventListener("click", reset);
        Object.values(sliders).forEach((s) =>
          s.addEventListener("input", updateUI)
        );

        const resizeListener = () => {
          resizeCanvases();
          drawTimeGraph();
          drawFreqGraph();
        };
        window.addEventListener("resize", resizeListener);
        simulationInstances["simple-harmonic-motion"].resizeListener =
          resizeListener;

        resizeCanvases();
        updateUI();
        reset();
      }

      // 3. Electric Circuits Simulation
      function initElectricCircuits() {
        const canvas = document.getElementById("circuit-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const voltageSlider = document.getElementById("voltage");
        const resistor1Slider = document.getElementById("resistor1");
        const resistor2Slider = document.getElementById("resistor2");
        const circuitTypeSelect = document.getElementById("circuit-type");
        const currentDisplay = document.getElementById("current-display");
        const powerDisplay = document.getElementById("power-display");

        let components = [];
        let current = 0;
        let power = 0;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawCircuit();
        }

        function drawCircuit() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw battery
          ctx.fillStyle = "#f59e0b";
          ctx.fillRect(50, canvas.height / 2 - 20, 30, 40);
          ctx.fillStyle = "#000";
          ctx.fillRect(65, canvas.height / 2 - 25, 2, 50);

          // Draw resistors based on circuit type
          const voltage = parseFloat(voltageSlider.value);
          const r1 = parseFloat(resistor1Slider.value);
          const r2 = parseFloat(resistor2Slider.value);
          const type = circuitTypeSelect.value;

          if (type === "series") {
            // Series circuit
            current = voltage / (r1 + r2);
            drawResistor(150, canvas.height / 2, r1, "#ef4444");
            drawResistor(250, canvas.height / 2, r2, "#3b82f6");

            // Draw wires
            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(80, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2);
            ctx.lineTo(180, canvas.height / 2);
            ctx.lineTo(180, canvas.height / 2);
            ctx.lineTo(220, canvas.height / 2);
            ctx.lineTo(220, canvas.height / 2);
            ctx.lineTo(280, canvas.height / 2);
            ctx.lineTo(280, canvas.height / 2);
            ctx.lineTo(320, canvas.height / 2);
            ctx.stroke();
          } else {
            // Parallel circuit
            const totalResistance = 1 / (1 / r1 + 1 / r2);
            current = voltage / totalResistance;

            drawResistor(150, canvas.height / 2 - 50, r1, "#ef4444");
            drawResistor(150, canvas.height / 2 + 50, r2, "#3b82f6");

            // Draw parallel wires
            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(80, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2);
            ctx.moveTo(120, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2 - 50);
            ctx.lineTo(180, canvas.height / 2 - 50);
            ctx.lineTo(180, canvas.height / 2);
            ctx.moveTo(120, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2 + 50);
            ctx.lineTo(180, canvas.height / 2 + 50);
            ctx.lineTo(180, canvas.height / 2);
            ctx.lineTo(220, canvas.height / 2);
            ctx.stroke();
          }

          power = voltage * current;
          currentDisplay.textContent = current.toFixed(3);
          powerDisplay.textContent = power.toFixed(3);

          // Draw current flow animation
          drawCurrentFlow(type);
        }

        function drawResistor(x, y, value, color) {
          ctx.fillStyle = color;
          ctx.fillRect(x - 15, y - 10, 30, 20);
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
          ctx.strokeRect(x - 15, y - 10, 30, 20);

          // Resistance value
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(`${value}Ω`, x, y + 5);
        }

        function drawCurrentFlow(type) {
          const currentStrength = Math.min(current * 10, 10);
          ctx.strokeStyle = `rgba(34, 197, 94, ${currentStrength / 10})`;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);

          ctx.beginPath();
          if (type === "series") {
            ctx.moveTo(85, canvas.height / 2);
            ctx.lineTo(320, canvas.height / 2);
          } else {
            ctx.moveTo(85, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2 - 50);
            ctx.lineTo(180, canvas.height / 2 - 50);
            ctx.lineTo(180, canvas.height / 2);
            ctx.moveTo(120, canvas.height / 2);
            ctx.lineTo(120, canvas.height / 2 + 50);
            ctx.lineTo(180, canvas.height / 2 + 50);
            ctx.lineTo(180, canvas.height / 2);
            ctx.lineTo(220, canvas.height / 2);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }

        function updateCircuit() {
          drawCircuit();
        }

        voltageSlider.addEventListener("input", updateCircuit);
        resistor1Slider.addEventListener("input", updateCircuit);
        resistor2Slider.addEventListener("input", updateCircuit);
        circuitTypeSelect.addEventListener("change", updateCircuit);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["electric-circuits"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 4. Optics Ray Tracing Simulation
      function initOpticsRayTracing() {
        const canvas = document.getElementById("optics-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const objectPosSlider = document.getElementById("object-pos");
        const focalLengthSlider = document.getElementById("focal-length");
        const lensTypeSelect = document.getElementById("lens-type");
        const imagePosDisplay = document.getElementById("image-pos");
        const magnificationDisplay = document.getElementById("magnification");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawOptics();
        }

        function drawOptics() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const objectPos = parseFloat(objectPosSlider.value);
          const focalLength = parseFloat(focalLengthSlider.value);
          const lensType = lensTypeSelect.value;

          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;

          // Draw lens
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 3;
          ctx.beginPath();
          if (lensType === "converging") {
            ctx.moveTo(centerX, centerY - 100);
            ctx.lineTo(centerX, centerY + 100);
          } else {
            // Diverging lens (simplified)
            ctx.moveTo(centerX - 10, centerY - 100);
            ctx.lineTo(centerX + 10, centerY + 100);
          }
          ctx.stroke();

          // Draw optical axis
          ctx.strokeStyle = "#475569";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(50, centerY);
          ctx.lineTo(canvas.width - 50, centerY);
          ctx.stroke();

          // Draw object
          const objectHeight = 40;
          const objectX = centerX - objectPos;
          ctx.fillStyle = "#3b82f6";
          ctx.fillRect(
            objectX - 2,
            centerY - objectHeight / 2,
            4,
            objectHeight
          );

          // Calculate image position using lens formula
          const imageDistance = 1 / (1 / focalLength - 1 / objectPos);
          const magnification = -imageDistance / objectPos;
          const imageHeight = objectHeight * magnification;
          const imageX = centerX + imageDistance;

          // Draw image
          ctx.fillStyle = "#ef4444";
          ctx.fillRect(
            imageX - 2,
            centerY - imageHeight / 2,
            4,
            Math.abs(imageHeight)
          );

          // Draw rays
          drawRays(
            objectX,
            centerY - objectHeight / 2,
            centerX,
            imageX,
            lensType,
            magnification
          );

          imagePosDisplay.textContent = imageDistance.toFixed(1);
          magnificationDisplay.textContent = magnification.toFixed(2);
        }

        function drawRays(
          objectX,
          objectY,
          lensX,
          imageX,
          lensType,
          magnification
        ) {
          ctx.strokeStyle = "#f59e0b";
          ctx.lineWidth = 2;

          // Ray 1: Parallel to axis, through focal point
          ctx.beginPath();
          ctx.moveTo(objectX, objectY);
          ctx.lineTo(lensX, objectY);
          if (lensType === "converging") {
            ctx.lineTo(
              imageX,
              objectY + (objectY - canvas.height / 2) * magnification
            );
          } else {
            // Diverging lens ray behavior
            ctx.lineTo(imageX, objectY - (objectY - canvas.height / 2) * 0.5);
          }
          ctx.stroke();

          // Ray 2: Through center of lens
          ctx.beginPath();
          ctx.moveTo(objectX, objectY);
          ctx.lineTo(lensX, canvas.height / 2);
          ctx.lineTo(
            imageX,
            canvas.height / 2 + (objectY - canvas.height / 2) * magnification
          );
          ctx.stroke();
        }

        function updateOptics() {
          drawOptics();
        }

        objectPosSlider.addEventListener("input", updateOptics);
        focalLengthSlider.addEventListener("input", updateOptics);
        lensTypeSelect.addEventListener("change", updateOptics);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["optics-ray-tracing"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 5. Energy Pendulum Simulation
      function initEnergyPendulum() {
        const canvas = document.getElementById("pendulum-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const lengthSlider = document.getElementById("pendulum-length");
        const gravitySlider = document.getElementById("gravity");
        const angleSlider = document.getElementById("initial-angle");
        const massSlider = document.getElementById("pendulum-mass");
        const energyGraphCanvas = document.getElementById("energy-graph");
        const energyCtx = energyGraphCanvas?.getContext("2d");

        let pendulum = {
          angle: Math.PI / 4,
          angularVelocity: 0,
          length: 1,
          mass: 1,
          gravity: 9.81,
          running: false,
        };

        let energyHistory = [];

        function resizeCanvases() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;

          if (energyGraphCanvas) {
            energyGraphCanvas.width = container.clientWidth;
            energyGraphCanvas.height = 200;
          }

          drawPendulum();
          drawEnergyGraph();
        }

        function drawPendulum() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const centerX = canvas.width / 2;
          const centerY = 100;
          const scale = 80;

          const x =
            centerX + Math.sin(pendulum.angle) * pendulum.length * scale;
          const y =
            centerY + Math.cos(pendulum.angle) * pendulum.length * scale;

          // Draw support
          ctx.fillStyle = "#94a3b8";
          ctx.fillRect(centerX - 20, centerY - 10, 40, 10);

          // Draw string
          ctx.strokeStyle = "#cbd5e1";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(x, y);
          ctx.stroke();

          // Draw bob
          const bobRadius = 15 + pendulum.mass * 2;
          ctx.fillStyle = "#3b82f6";
          ctx.beginPath();
          ctx.arc(x, y, bobRadius, 0, Math.PI * 2);
          ctx.fill();

          // Draw energy indicators
          const potentialEnergy =
            pendulum.mass * pendulum.gravity * (y - centerY);
          const kineticEnergy =
            0.5 *
            pendulum.mass *
            Math.pow(pendulum.angularVelocity * pendulum.length, 2);
          const totalEnergy = potentialEnergy + kineticEnergy;

          // Update energy history
          energyHistory.push({
            potential: potentialEnergy,
            kinetic: kineticEnergy,
            total: totalEnergy,
          });

          if (energyHistory.length > 100) energyHistory.shift();
        }

        function drawEnergyGraph() {
          if (!energyCtx) return;
          energyCtx.clearRect(
            0,
            0,
            energyGraphCanvas.width,
            energyGraphCanvas.height
          );

          if (energyHistory.length < 2) return;

          const maxEnergy = Math.max(...energyHistory.map((e) => e.total));
          const scaleY = energyGraphCanvas.height / (maxEnergy || 1);

          // Draw potential energy
          energyCtx.strokeStyle = "#3b82f6";
          energyCtx.lineWidth = 2;
          energyCtx.beginPath();
          energyHistory.forEach((point, i) => {
            const x = (i / energyHistory.length) * energyGraphCanvas.width;
            const y = energyGraphCanvas.height - point.potential * scaleY;
            if (i === 0) energyCtx.moveTo(x, y);
            else energyCtx.lineTo(x, y);
          });
          energyCtx.stroke();

          // Draw kinetic energy
          energyCtx.strokeStyle = "#ef4444";
          energyCtx.beginPath();
          energyHistory.forEach((point, i) => {
            const x = (i / energyHistory.length) * energyGraphCanvas.width;
            const y = energyGraphCanvas.height - point.kinetic * scaleY;
            if (i === 0) energyCtx.moveTo(x, y);
            else energyCtx.lineTo(x, y);
          });
          energyCtx.stroke();
        }

        function animatePendulum() {
          if (!pendulum.running) return;

          const dt = 0.016; // ~60fps
          const angularAcceleration =
            (-pendulum.gravity / pendulum.length) * Math.sin(pendulum.angle);

          pendulum.angularVelocity += angularAcceleration * dt;
          pendulum.angle += pendulum.angularVelocity * dt;

          // Add some damping
          pendulum.angularVelocity *= 0.998;

          drawPendulum();
          drawEnergyGraph();

          simulationInstances["energy-pendulum"].animationFrameId =
            requestAnimationFrame(animatePendulum);
        }

        function updatePendulum() {
          pendulum.length = parseFloat(lengthSlider.value);
          pendulum.gravity = parseFloat(gravitySlider.value);
          pendulum.mass = parseFloat(massSlider.value);
          pendulum.angle = (parseFloat(angleSlider.value) * Math.PI) / 180;
          pendulum.angularVelocity = 0;

          drawPendulum();
          drawEnergyGraph();
        }

        function startPendulum() {
          pendulum.running = true;
          animatePendulum();
        }

        function stopPendulum() {
          pendulum.running = false;
          if (simulationInstances["energy-pendulum"].animationFrameId) {
            cancelAnimationFrame(
              simulationInstances["energy-pendulum"].animationFrameId
            );
          }
        }

        // Set up event listeners
        lengthSlider.addEventListener("input", updatePendulum);
        gravitySlider.addEventListener("input", updatePendulum);
        angleSlider.addEventListener("input", updatePendulum);
        massSlider.addEventListener("input", updatePendulum);

        document
          .getElementById("start-pendulum")
          ?.addEventListener("click", startPendulum);
        document
          .getElementById("stop-pendulum")
          ?.addEventListener("click", stopPendulum);

        const resizeListener = () => resizeCanvases();
        window.addEventListener("resize", resizeListener);
        simulationInstances["energy-pendulum"].resizeListener = resizeListener;

        resizeCanvases();
        updatePendulum();
      }

      // 6. Virtual Titration Simulation
      function initVirtualTitration() {
        const canvas = document.getElementById("titration-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const acidSlider = document.getElementById("acid-concentration");
        const baseSlider = document.getElementById("base-concentration");
        const volumeSlider = document.getElementById("volume-added");
        const phDisplay = document.getElementById("ph-value");
        const indicatorSelect = document.getElementById("indicator");

        let titrationData = [];
        let currentVolume = 0;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawTitration();
        }

        function drawTitration() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const acidConc = parseFloat(acidSlider.value);
          const baseConc = parseFloat(baseSlider.value);
          currentVolume = parseFloat(volumeSlider.value);
          const indicator = indicatorSelect.value;

          // Draw beaker
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(canvas.width / 2 - 80, canvas.height - 50);
          ctx.lineTo(canvas.width / 2 - 60, canvas.height - 150);
          ctx.lineTo(canvas.width / 2 + 60, canvas.height - 150);
          ctx.lineTo(canvas.width / 2 + 80, canvas.height - 50);
          ctx.closePath();
          ctx.stroke();

          // Calculate pH
          const equivalenceVolume = (acidConc * 0.05) / baseConc; // Assuming 50ml acid
          let pH = 0;

          if (currentVolume < equivalenceVolume) {
            // Before equivalence point
            const remainingAcid = acidConc * 0.05 - baseConc * currentVolume;
            pH = -Math.log10(remainingAcid / (0.05 + currentVolume));
          } else if (currentVolume > equivalenceVolume) {
            // After equivalence point
            const excessBase = baseConc * (currentVolume - equivalenceVolume);
            pH = 14 + Math.log10(excessBase / (0.05 + currentVolume));
          } else {
            // At equivalence point
            pH = 7;
          }

          pH = Math.max(0, Math.min(14, pH));

          // Draw solution with color based on pH and indicator
          const solutionColor = getSolutionColor(pH, indicator);
          ctx.fillStyle = solutionColor;
          ctx.beginPath();
          const solutionHeight = 100 * (currentVolume / 0.1); // Scale to 100ml max
          ctx.moveTo(canvas.width / 2 - 60, canvas.height - 50);
          ctx.lineTo(
            canvas.width / 2 - 60,
            canvas.height - 50 - solutionHeight
          );
          ctx.lineTo(
            canvas.width / 2 + 60,
            canvas.height - 50 - solutionHeight
          );
          ctx.lineTo(canvas.width / 2 + 80, canvas.height - 50);
          ctx.closePath();
          ctx.fill();

          // Update titration curve
          titrationData.push({ volume: currentVolume, pH: pH });
          if (titrationData.length > 50) titrationData.shift();
          drawTitrationCurve();

          phDisplay.textContent = pH.toFixed(2);
        }

        function getSolutionColor(pH, indicator) {
          if (indicator === "phenolphthalein") {
            return pH > 8.3
              ? "rgba(255, 105, 180, 0.7)"
              : "rgba(255, 255, 255, 0.7)";
          } else if (indicator === "methyl-orange") {
            return pH < 3.1
              ? "rgba(255, 165, 0, 0.7)"
              : "rgba(255, 255, 0, 0.7)";
          } else {
            // Universal indicator
            if (pH < 3) return "rgba(255, 0, 0, 0.7)";
            if (pH < 6) return "rgba(255, 165, 0, 0.7)";
            if (pH < 8) return "rgba(255, 255, 0, 0.7)";
            if (pH < 11) return "rgba(0, 255, 0, 0.7)";
            return "rgba(128, 0, 128, 0.7)";
          }
        }

        function drawTitrationCurve() {
          // Draw a small titration curve in corner
          if (titrationData.length < 2) return;

          const graphWidth = 200;
          const graphHeight = 100;
          const graphX = canvas.width - graphWidth - 20;
          const graphY = 20;

          // Draw graph background
          ctx.fillStyle = "rgba(30, 41, 59, 0.8)";
          ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
          ctx.strokeStyle = "#94a3b8";
          ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);

          // Draw axes
          ctx.strokeStyle = "#cbd5e1";
          ctx.beginPath();
          ctx.moveTo(graphX + 10, graphY + 10);
          ctx.lineTo(graphX + 10, graphY + graphHeight - 10);
          ctx.moveTo(graphX + 10, graphY + graphHeight - 10);
          ctx.lineTo(graphX + graphWidth - 10, graphY + graphHeight - 10);
          ctx.stroke();

          // Draw curve
          ctx.strokeStyle = "#3b82f6";
          ctx.lineWidth = 2;
          ctx.beginPath();

          titrationData.forEach((point, i) => {
            const x = graphX + 10 + (point.volume / 0.1) * (graphWidth - 20);
            const y =
              graphY + graphHeight - 10 - (point.pH / 14) * (graphHeight - 20);

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          });
          ctx.stroke();
        }

        function updateTitration() {
          drawTitration();
        }

        acidSlider.addEventListener("input", updateTitration);
        baseSlider.addEventListener("input", updateTitration);
        volumeSlider.addEventListener("input", updateTitration);
        indicatorSelect.addEventListener("change", updateTitration);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["virtual-titration"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 7. Chemical Kinetics Simulation
      function initChemicalKinetics() {
        const canvas = document.getElementById("kinetics-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const tempSlider = document.getElementById("temperature");
        const concentrationSlider = document.getElementById("concentration");
        const catalystSlider = document.getElementById("catalyst");
        const timeDisplay = document.getElementById("reaction-time");
        const rateDisplay = document.getElementById("reaction-rate");

        let particles = [];
        let reactionRate = 0;
        let time = 0;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          initParticles();
          drawKinetics();
        }

        function initParticles() {
          particles = [];
          const concentration = parseFloat(concentrationSlider.value);
          const numParticles = Math.floor(concentration * 50);

          for (let i = 0; i < numParticles; i++) {
            particles.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              type: Math.random() > 0.5 ? "A" : "B",
              reacted: false,
            });
          }
        }

        function drawKinetics() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const temperature = parseFloat(tempSlider.value);
          const catalyst = parseFloat(catalystSlider.value);

          // Update particle movement and reactions
          let reactionsThisFrame = 0;

          particles.forEach((particle) => {
            if (!particle.reacted) {
              // Update position with temperature effect
              const speedMultiplier = temperature / 300;
              particle.x += particle.vx * speedMultiplier;
              particle.y += particle.vy * speedMultiplier;

              // Bounce off walls
              if (particle.x <= 0 || particle.x >= canvas.width)
                particle.vx *= -1;
              if (particle.y <= 0 || particle.y >= canvas.height)
                particle.vy *= -1;

              // Check for collisions and reactions
              particles.forEach((other) => {
                if (!other.reacted && particle.type !== other.type) {
                  const dx = particle.x - other.x;
                  const dy = particle.y - other.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);

                  if (distance < 15) {
                    // Reaction probability increases with temperature and catalyst
                    const reactionProb = (temperature / 500) * (1 + catalyst);
                    if (Math.random() < reactionProb) {
                      particle.reacted = true;
                      other.reacted = true;
                      reactionsThisFrame++;
                    }
                  }
                }
              });
            }

            // Draw particle
            ctx.fillStyle = particle.reacted
              ? "#10b981"
              : particle.type === "A"
              ? "#3b82f6"
              : "#ef4444";

            ctx.beginPath();
            ctx.arc(particle.x, particle.y, 8, 0, Math.PI * 2);
            ctx.fill();
          });

          // Update reaction rate
          time += 0.016;
          reactionRate = reactionsThisFrame / time;

          timeDisplay.textContent = time.toFixed(1);
          rateDisplay.textContent = reactionRate.toFixed(3);

          if (simulationInstances["chemical-kinetics"].running) {
            simulationInstances["chemical-kinetics"].animationFrameId =
              requestAnimationFrame(drawKinetics);
          }
        }

        function startKinetics() {
          simulationInstances["chemical-kinetics"].running = true;
          drawKinetics();
        }

        function stopKinetics() {
          simulationInstances["chemical-kinetics"].running = false;
          if (simulationInstances["chemical-kinetics"].animationFrameId) {
            cancelAnimationFrame(
              simulationInstances["chemical-kinetics"].animationFrameId
            );
          }
        }

        function resetKinetics() {
          time = 0;
          initParticles();
          drawKinetics();
        }

        tempSlider.addEventListener("input", drawKinetics);
        concentrationSlider.addEventListener("input", () => {
          initParticles();
          drawKinetics();
        });
        catalystSlider.addEventListener("input", drawKinetics);

        document
          .getElementById("start-kinetics")
          ?.addEventListener("click", startKinetics);
        document
          .getElementById("stop-kinetics")
          ?.addEventListener("click", stopKinetics);
        document
          .getElementById("reset-kinetics")
          ?.addEventListener("click", resetKinetics);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["chemical-kinetics"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 8. Electrochemistry Simulation
      function initElectrochemistry() {
        const canvas = document.getElementById("electrochem-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const metal1Select = document.getElementById("metal1");
        const metal2Select = document.getElementById("metal2");
        const concentrationSlider = document.getElementById(
          "solution-concentration"
        );
        const voltageDisplay = document.getElementById("cell-voltage");
        const currentDisplay = document.getElementById("cell-current");

        const metalProperties = {
          Zn: { potential: -0.76, color: "#a8a8a8" },
          Fe: { potential: -0.44, color: "#b0b0b0" },
          Pb: { potential: -0.13, color: "#808080" },
          Cu: { potential: +0.34, color: "#b87333" },
          Ag: { potential: +0.8, color: "#c0c0c0" },
          Au: { potential: +1.5, color: "#ffd700" },
        };

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawElectrochemicalCell();
        }

        function drawElectrochemicalCell() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const metal1 = metal1Select.value;
          const metal2 = metal2Select.value;
          const concentration = parseFloat(concentrationSlider.value);

          // Calculate cell voltage
          const potential1 = metalProperties[metal1].potential;
          const potential2 = metalProperties[metal2].potential;
          let voltage = Math.abs(potential2 - potential1);

          // Nernst equation effect
          voltage = voltage - (0.059 / 2) * Math.log10(1 / concentration);

          // Determine anode and cathode
          const anode = potential1 < potential2 ? metal1 : metal2;
          const cathode = potential1 < potential2 ? metal2 : metal1;

          // Draw electrochemical cell
          const centerX = canvas.width / 2;

          // Left beaker (anode)
          drawBeaker(
            centerX - 150,
            canvas.height - 100,
            metalProperties[anode].color,
            "Anode"
          );
          // Right beaker (cathode)
          drawBeaker(
            centerX + 50,
            canvas.height - 100,
            metalProperties[cathode].color,
            "Cathode"
          );

          // Draw salt bridge
          ctx.fillStyle = "#8b5a2b";
          ctx.fillRect(centerX - 20, canvas.height - 180, 40, 80);

          // Draw electron flow
          ctx.strokeStyle = "#f59e0b";
          ctx.lineWidth = 3;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(centerX - 120, canvas.height - 150);
          ctx.lineTo(centerX + 120, canvas.height - 150);
          ctx.stroke();
          ctx.setLineDash([]);

          // Draw ion movement
          drawIonMovement(centerX);

          voltageDisplay.textContent = voltage.toFixed(2);
          currentDisplay.textContent = (voltage * 0.1).toFixed(3); // Simulated current
        }

        function drawBeaker(x, y, metalColor, label) {
          // Beaker outline
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x - 40, y);
          ctx.lineTo(x - 30, y - 80);
          ctx.lineTo(x + 30, y - 80);
          ctx.lineTo(x + 40, y);
          ctx.closePath();
          ctx.stroke();

          // Solution
          ctx.fillStyle = "rgba(64, 156, 255, 0.3)";
          ctx.fill();

          // Metal electrode
          ctx.fillStyle = metalColor;
          ctx.fillRect(x - 5, y - 100, 10, 100);

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(label, x, y + 20);
        }

        function drawIonMovement(centerX) {
          // Draw cation movement
          ctx.fillStyle = "#3b82f6";
          for (let i = 0; i < 5; i++) {
            const y = canvas.height - 120 - i * 15;
            ctx.beginPath();
            ctx.arc(centerX - 10, y, 4, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw anion movement
          ctx.fillStyle = "#ef4444";
          for (let i = 0; i < 5; i++) {
            const y = canvas.height - 120 - i * 15;
            ctx.beginPath();
            ctx.arc(centerX + 10, y, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        function updateElectrochemistry() {
          drawElectrochemicalCell();
        }

        metal1Select.addEventListener("change", updateElectrochemistry);
        metal2Select.addEventListener("change", updateElectrochemistry);
        concentrationSlider.addEventListener("input", updateElectrochemistry);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["electrochemistry-galvanic-cells"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 9. Equilibrium Simulation
      function initEquilibrium() {
        const canvas = document.getElementById("equilibrium-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const tempSlider = document.getElementById("eq-temperature");
        const pressureSlider = document.getElementById("pressure");
        const concentrationSlider = document.getElementById(
          "initial-concentration"
        );
        const kDisplay = document.getElementById("equilibrium-constant");
        const progressDisplay = document.getElementById("reaction-progress");

        let reactants = 100;
        let products = 0;
        let equilibriumConstant = 1;
        let forwardRate = 0.1;
        let reverseRate = 0.1;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawEquilibrium();
        }

        function drawEquilibrium() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const temperature = parseFloat(tempSlider.value);
          const pressure = parseFloat(pressureSlider.value);
          const initialConc = parseFloat(concentrationSlider.value);

          // Update equilibrium based on conditions
          equilibriumConstant = Math.exp((-1 / temperature) * 1000); // Simplified Arrhenius
          forwardRate = (0.1 * temperature) / 300;
          reverseRate = 0.1 * equilibriumConstant;

          // Update concentrations
          const forwardReaction = reactants * forwardRate;
          const reverseReaction = products * reverseRate;

          reactants -= forwardReaction - reverseReaction;
          products += forwardReaction - reverseReaction;

          // Ensure values stay reasonable
          reactants = Math.max(0, Math.min(initialConc * 100, reactants));
          products = Math.max(0, Math.min(initialConc * 100, products));

          // Draw reaction vessel
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 3;
          ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);

          // Draw reactants and products
          const total = reactants + products;
          const reactantPercent = reactants / total;
          const productPercent = products / total;

          // Reactants (left side)
          ctx.fillStyle = "rgba(59, 130, 246, 0.7)";
          ctx.fillRect(
            60,
            60,
            (canvas.width - 120) * reactantPercent,
            canvas.height - 120
          );

          // Products (right side)
          ctx.fillStyle = "rgba(239, 68, 68, 0.7)";
          ctx.fillRect(
            60 + (canvas.width - 120) * reactantPercent,
            60,
            (canvas.width - 120) * productPercent,
            canvas.height - 120
          );

          // Draw particles
          drawParticles(reactants, products, reactantPercent);

          // Draw equilibrium arrow
          ctx.strokeStyle = "#10b981";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(canvas.width / 2 - 30, canvas.height / 2);
          ctx.lineTo(canvas.width / 2 + 30, canvas.height / 2);
          ctx.moveTo(canvas.width / 2 + 20, canvas.height / 2 - 10);
          ctx.lineTo(canvas.width / 2 + 30, canvas.height / 2);
          ctx.lineTo(canvas.width / 2 + 20, canvas.height / 2 + 10);
          ctx.stroke();

          kDisplay.textContent = equilibriumConstant.toFixed(3);
          progressDisplay.textContent =
            ((products / total) * 100).toFixed(1) + "%";

          if (simulationInstances["equilibrium-le-chatelier"].running) {
            simulationInstances["equilibrium-le-chatelier"].animationFrameId =
              requestAnimationFrame(drawEquilibrium);
          }
        }

        function drawParticles(reactants, products, reactantPercent) {
          // Draw reactant particles (blue)
          ctx.fillStyle = "#3b82f6";
          for (let i = 0; i < reactants / 10; i++) {
            const x =
              70 + Math.random() * (canvas.width - 140) * reactantPercent;
            const y = 70 + Math.random() * (canvas.height - 140);
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw product particles (red)
          ctx.fillStyle = "#ef4444";
          for (let i = 0; i < products / 10; i++) {
            const x =
              70 +
              (canvas.width - 140) * reactantPercent +
              Math.random() * (canvas.width - 140) * (1 - reactantPercent);
            const y = 70 + Math.random() * (canvas.height - 140);
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        function startEquilibrium() {
          simulationInstances["equilibrium-le-chatelier"].running = true;
          drawEquilibrium();
        }

        function stopEquilibrium() {
          simulationInstances["equilibrium-le-chatelier"].running = false;
          if (
            simulationInstances["equilibrium-le-chatelier"].animationFrameId
          ) {
            cancelAnimationFrame(
              simulationInstances["equilibrium-le-chatelier"].animationFrameId
            );
          }
        }

        function resetEquilibrium() {
          reactants = parseFloat(concentrationSlider.value) * 100;
          products = 0;
          drawEquilibrium();
        }

        tempSlider.addEventListener("input", drawEquilibrium);
        pressureSlider.addEventListener("input", drawEquilibrium);
        concentrationSlider.addEventListener("input", resetEquilibrium);

        document
          .getElementById("start-equilibrium")
          ?.addEventListener("click", startEquilibrium);
        document
          .getElementById("stop-equilibrium")
          ?.addEventListener("click", stopEquilibrium);
        document
          .getElementById("reset-equilibrium")
          ?.addEventListener("click", resetEquilibrium);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["equilibrium-le-chatelier"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 10. Molecular Modeling Simulation
      function initMolecularModeling() {
        const canvas = document.getElementById("molecular-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const moleculeSelect = document.getElementById("molecule-type");
        const viewTypeSelect = document.getElementById("view-type");
        const bondLengthSlider = document.getElementById("bond-length");
        const angleSlider = document.getElementById("bond-angle");

        const molecules = {
          water: {
            atoms: [
              { element: "O", x: 0, y: 0, z: 0, color: "#ef4444" },
              { element: "H", x: -1, y: 1, z: 0, color: "#94a3b8" },
              { element: "H", x: 1, y: 1, z: 0, color: "#94a3b8" },
            ],
            bonds: [
              [0, 1],
              [0, 2],
            ],
          },
          methane: {
            atoms: [
              { element: "C", x: 0, y: 0, z: 0, color: "#333333" },
              { element: "H", x: 1, y: 1, z: 1, color: "#94a3b8" },
              { element: "H", x: -1, y: -1, z: 1, color: "#94a3b8" },
              { element: "H", x: 1, y: -1, z: -1, color: "#94a3b8" },
              { element: "H", x: -1, y: 1, z: -1, color: "#94a3b8" },
            ],
            bonds: [
              [0, 1],
              [0, 2],
              [0, 3],
              [0, 4],
            ],
          },
          ammonia: {
            atoms: [
              { element: "N", x: 0, y: 0, z: 0, color: "#3b82f6" },
              { element: "H", x: 1, y: 1, z: 0, color: "#94a3b8" },
              { element: "H", x: -1, y: 1, z: 0, color: "#94a3b8" },
              { element: "H", x: 0, y: -1, z: 1, color: "#94a3b8" },
            ],
            bonds: [
              [0, 1],
              [0, 2],
              [0, 3],
            ],
          },
        };

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawMolecule();
        }

        function drawMolecule() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const moleculeType = moleculeSelect.value;
          const viewType = viewTypeSelect.value;
          const bondLength = parseFloat(bondLengthSlider.value);
          const bondAngle = parseFloat(angleSlider.value);

          const molecule = molecules[moleculeType];
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const scale = 40;

          // Apply transformations based on view type
          let rotationX = 0,
            rotationY = 0,
            rotationZ = 0;

          switch (viewType) {
            case "wireframe":
              rotationX = Math.PI / 6;
              rotationY = Math.PI / 4;
              break;
            case "ball-stick":
              rotationX = Math.PI / 4;
              rotationY = Math.PI / 6;
              break;
            case "space-filling":
              rotationX = Math.PI / 3;
              rotationY = Math.PI / 3;
              break;
          }

          // Draw bonds first (so atoms appear on top)
          molecule.bonds.forEach((bond) => {
            const atom1 = molecule.atoms[bond[0]];
            const atom2 = molecule.atoms[bond[1]];

            const pos1 = rotatePoint(
              atom1.x * bondLength,
              atom1.y * bondLength,
              atom1.z * bondLength,
              rotationX,
              rotationY,
              rotationZ
            );
            const pos2 = rotatePoint(
              atom2.x * bondLength,
              atom2.y * bondLength,
              atom2.z * bondLength,
              rotationX,
              rotationY,
              rotationZ
            );

            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = viewType === "space-filling" ? 8 : 3;
            ctx.beginPath();
            ctx.moveTo(centerX + pos1.x * scale, centerY + pos1.y * scale);
            ctx.lineTo(centerX + pos2.x * scale, centerY + pos2.y * scale);
            ctx.stroke();
          });

          // Draw atoms
          molecule.atoms.forEach((atom) => {
            const pos = rotatePoint(
              atom.x * bondLength,
              atom.y * bondLength,
              atom.z * bondLength,
              rotationX,
              rotationY,
              rotationZ
            );

            const radius =
              viewType === "space-filling"
                ? atom.element === "O"
                  ? 12
                  : atom.element === "N"
                  ? 10
                  : atom.element === "C"
                  ? 14
                  : 8
                : 8;

            ctx.fillStyle = atom.color;
            ctx.beginPath();
            ctx.arc(
              centerX + pos.x * scale,
              centerY + pos.y * scale,
              radius,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Add element symbol for ball-stick model
            if (viewType === "ball-stick") {
              ctx.fillStyle = "#fff";
              ctx.font = "10px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(
                atom.element,
                centerX + pos.x * scale,
                centerY + pos.y * scale
              );
            }
          });
        }

        function rotatePoint(x, y, z, rx, ry, rz) {
          // Simple 3D rotation (simplified)
          const cosX = Math.cos(rx),
            sinX = Math.sin(rx);
          const cosY = Math.cos(ry),
            sinY = Math.sin(ry);

          let y1 = y * cosX - z * sinX;
          let z1 = y * sinX + z * cosX;

          let x1 = x * cosY + z1 * sinY;
          let z2 = -x * sinY + z1 * cosY;

          return { x: x1, y: y1, z: z2 };
        }

        function updateMolecule() {
          drawMolecule();
        }

        moleculeSelect.addEventListener("change", updateMolecule);
        viewTypeSelect.addEventListener("change", updateMolecule);
        bondLengthSlider.addEventListener("input", updateMolecule);
        angleSlider.addEventListener("input", updateMolecule);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["molecular-modeling"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 11. Cell Structure Explorer
      function initCellExplorer() {
        const canvas = document.getElementById("cell-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const cellTypeSelect = document.getElementById("cell-type");
        const zoomSlider = document.getElementById("cell-zoom");
        const structureSelect = document.getElementById("cell-structure");

        let selectedOrganelle = null;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawCell();
        }

        function drawCell() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const cellType = cellTypeSelect.value;
          const zoom = parseFloat(zoomSlider.value);
          const structure = structureSelect.value;

          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const baseRadius = Math.min(canvas.width, canvas.height) * 0.3 * zoom;

          // Draw cell membrane
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
          ctx.stroke();

          if (cellType === "plant") {
            // Draw cell wall
            ctx.strokeStyle = "#8b5a2b";
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius + 10, 0, Math.PI * 2);
            ctx.stroke();

            // Draw chloroplasts
            drawOrganelle(
              centerX - baseRadius / 2,
              centerY - baseRadius / 3,
              20,
              "#10b981",
              "Chloroplast"
            );
            drawOrganelle(
              centerX + baseRadius / 3,
              centerY + baseRadius / 4,
              18,
              "#10b981",
              "Chloroplast"
            );

            // Draw large central vacuole
            drawOrganelle(
              centerX,
              centerY,
              baseRadius * 0.5,
              "#a855f7",
              "Vacuole"
            );
          }

          // Common organelles
          drawOrganelle(
            centerX,
            centerY,
            baseRadius * 0.3,
            "#3b82f6",
            "Nucleus"
          );
          drawOrganelle(
            centerX + baseRadius / 2,
            centerY - baseRadius / 2,
            15,
            "#ef4444",
            "Mitochondria"
          );
          drawOrganelle(
            centerX - baseRadius / 2,
            centerY + baseRadius / 2,
            12,
            "#f59e0b",
            "Lysosome"
          );
          drawOrganelle(
            centerX,
            centerY - baseRadius / 2,
            25,
            "#84cc16",
            "Golgi Apparatus"
          );

          // Draw endoplasmic reticulum
          ctx.strokeStyle = "#f97316";
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = baseRadius * 0.6 + Math.sin(i) * 5;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();

          // Highlight selected structure
          if (structure !== "all") {
            highlightStructure(structure, centerX, centerY, baseRadius);
          }
        }

        function drawOrganelle(x, y, radius, color, label) {
          ctx.fillStyle = color + "80"; // Add transparency
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.stroke();

          // Add label on hover (simplified)
          if (isMouseOver(x, y, radius)) {
            ctx.fillStyle = "#fff";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.fillText(label, x, y - radius - 10);
          }
        }

        function highlightStructure(structure, centerX, centerY, baseRadius) {
          ctx.strokeStyle = "#f59e0b";
          ctx.lineWidth = 4;

          switch (structure) {
            case "nucleus":
              ctx.beginPath();
              ctx.arc(centerX, centerY, baseRadius * 0.3, 0, Math.PI * 2);
              ctx.stroke();
              break;
            case "mitochondria":
              ctx.beginPath();
              ctx.arc(
                centerX + baseRadius / 2,
                centerY - baseRadius / 2,
                20,
                0,
                Math.PI * 2
              );
              ctx.stroke();
              break;
            case "chloroplast":
              ctx.beginPath();
              ctx.arc(
                centerX - baseRadius / 2,
                centerY - baseRadius / 3,
                25,
                0,
                Math.PI * 2
              );
              ctx.stroke();
              break;
          }
        }

        function isMouseOver(x, y, radius) {
          // Simplified - in real implementation, track mouse position
          return false;
        }

        function updateCell() {
          drawCell();
        }

        cellTypeSelect.addEventListener("change", updateCell);
        zoomSlider.addEventListener("input", updateCell);
        structureSelect.addEventListener("change", updateCell);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["cell-structure-explorer"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 12. Enzyme Kinetics Simulation
      function initEnzymeKinetics() {
        const canvas = document.getElementById("enzyme-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const substrateSlider = document.getElementById(
          "substrate-concentration"
        );
        const enzymeSlider = document.getElementById("enzyme-concentration");
        const tempSlider = document.getElementById("enzyme-temperature");
        const phSlider = document.getElementById("ph-level");
        const rateDisplay = document.getElementById("reaction-rate");
        const michaelisDisplay = document.getElementById("michaelis-constant");

        let substrates = [];
        let enzymes = [];
        let products = [];
        let reactionRate = 0;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          initParticles();
          drawEnzymeKinetics();
        }

        function initParticles() {
          substrates = [];
          enzymes = [];
          products = [];

          const substrateConc = parseFloat(substrateSlider.value);
          const enzymeConc = parseFloat(enzymeSlider.value);

          for (let i = 0; i < substrateConc * 20; i++) {
            substrates.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              bound: false,
            });
          }

          for (let i = 0; i < enzymeConc * 10; i++) {
            enzymes.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: (Math.random() - 0.5) * 1,
              vy: (Math.random() - 0.5) * 1,
              occupied: false,
            });
          }
        }

        function drawEnzymeKinetics() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const temperature = parseFloat(tempSlider.value);
          const pH = parseFloat(phSlider.value);

          let reactionsThisFrame = 0;

          // Update enzyme movement
          enzymes.forEach((enzyme) => {
            if (!enzyme.occupied) {
              enzyme.x += enzyme.vx * (temperature / 300);
              enzyme.y += enzyme.vy * (temperature / 300);

              // Bounce off walls
              if (enzyme.x <= 0 || enzyme.x >= canvas.width) enzyme.vx *= -1;
              if (enzyme.y <= 0 || enzyme.y >= canvas.height) enzyme.vy *= -1;
            }

            // Draw enzyme
            ctx.fillStyle = enzyme.occupied ? "#f59e0b" : "#3b82f6";
            ctx.beginPath();
            ctx.arc(enzyme.x, enzyme.y, 12, 0, Math.PI * 2);
            ctx.fill();

            // Draw active site
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(enzyme.x, enzyme.y, 6, 0, Math.PI * 2);
            ctx.stroke();
          });

          // Update substrate movement and binding
          substrates.forEach((substrate) => {
            if (!substrate.bound) {
              substrate.x += substrate.vx * (temperature / 300);
              substrate.y += substrate.vy * (temperature / 300);

              // Bounce off walls
              if (substrate.x <= 0 || substrate.x >= canvas.width)
                substrate.vx *= -1;
              if (substrate.y <= 0 || substrate.y >= canvas.height)
                substrate.vy *= -1;

              // Check for enzyme binding
              enzymes.forEach((enzyme) => {
                if (!enzyme.occupied) {
                  const dx = substrate.x - enzyme.x;
                  const dy = substrate.y - enzyme.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);

                  if (distance < 18) {
                    // Binding probability depends on pH
                    const optimalPH = 7.0;
                    const phEffect = 1 - Math.abs(pH - optimalPH) * 0.1;
                    const bindProb = 0.1 * phEffect;

                    if (Math.random() < bindProb) {
                      substrate.bound = true;
                      enzyme.occupied = true;
                      substrate.enzymeIndex = enzymes.indexOf(enzyme);

                      // Convert to product after delay
                      setTimeout(() => {
                        if (substrate.bound) {
                          products.push({
                            x: substrate.x,
                            y: substrate.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                          });
                          substrates.splice(substrates.indexOf(substrate), 1);
                          enzyme.occupied = false;
                          reactionsThisFrame++;
                        }
                      }, 500);
                    }
                  }
                }
              });
            } else {
              // Substrate is bound to enzyme
              const enzyme = enzymes[substrate.enzymeIndex];
              substrate.x = enzyme.x + 8;
              substrate.y = enzyme.y;
            }

            // Draw substrate
            ctx.fillStyle = substrate.bound ? "#f59e0b" : "#ef4444";
            ctx.beginPath();
            ctx.arc(substrate.x, substrate.y, 8, 0, Math.PI * 2);
            ctx.fill();
          });

          // Update and draw products
          products.forEach((product) => {
            product.x += product.vx;
            product.y += product.vy;

            // Remove if out of bounds
            if (
              product.x < 0 ||
              product.x > canvas.width ||
              product.y < 0 ||
              product.y > canvas.height
            ) {
              products.splice(products.indexOf(product), 1);
            }

            // Draw product
            ctx.fillStyle = "#10b981";
            ctx.beginPath();
            ctx.arc(product.x, product.y, 6, 0, Math.PI * 2);
            ctx.fill();
          });

          // Calculate reaction rate (Michaelis-Menten simplified)
          const substrateConc = parseFloat(substrateSlider.value);
          const enzymeConc = parseFloat(enzymeSlider.value);
          const vmax = enzymeConc * 0.1;
          const km = 5; // Michaelis constant
          reactionRate = (vmax * substrateConc) / (km + substrateConc);

          // Adjust for temperature and pH
          const tempEffect = Math.exp(-Math.abs(temperature - 37) * 0.1);
          const phEffect = 1 - Math.abs(pH - 7) * 0.1;
          reactionRate *= tempEffect * phEffect;

          rateDisplay.textContent = reactionRate.toFixed(3);
          michaelisDisplay.textContent = km.toFixed(1);

          if (simulationInstances["enzyme-kinetics"].running) {
            simulationInstances["enzyme-kinetics"].animationFrameId =
              requestAnimationFrame(drawEnzymeKinetics);
          }
        }

        function startEnzymeKinetics() {
          simulationInstances["enzyme-kinetics"].running = true;
          drawEnzymeKinetics();
        }

        function stopEnzymeKinetics() {
          simulationInstances["enzyme-kinetics"].running = false;
          if (simulationInstances["enzyme-kinetics"].animationFrameId) {
            cancelAnimationFrame(
              simulationInstances["enzyme-kinetics"].animationFrameId
            );
          }
        }

        substrateSlider.addEventListener("input", () => {
          initParticles();
          drawEnzymeKinetics();
        });
        enzymeSlider.addEventListener("input", () => {
          initParticles();
          drawEnzymeKinetics();
        });
        tempSlider.addEventListener("input", drawEnzymeKinetics);
        phSlider.addEventListener("input", drawEnzymeKinetics);

        document
          .getElementById("start-enzyme")
          ?.addEventListener("click", startEnzymeKinetics);
        document
          .getElementById("stop-enzyme")
          ?.addEventListener("click", stopEnzymeKinetics);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["enzyme-kinetics"].resizeListener = resizeListener;

        resizeCanvas();
      }

      // 13-23. Remaining Simulations (implemented with similar structure)

      // 13. Genetics Simulation
      function initGenetics() {
        const canvas = document.getElementById("genetics-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        // Basic Punnett square implementation
        const parent1Select = document.getElementById("parent1-genotype");
        const parent2Select = document.getElementById("parent2-genotype");
        const traitSelect = document.getElementById("trait-type");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawPunnettSquare();
        }

        function drawPunnettSquare() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const parent1 = parent1Select.value;
          const parent2 = parent2Select.value;
          const trait = traitSelect.value;

          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const size = 200;

          // Draw Punnett square grid
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 2;
          ctx.strokeRect(centerX - size / 2, centerY - size / 2, size, size);
          ctx.beginPath();
          ctx.moveTo(centerX, centerY - size / 2);
          ctx.lineTo(centerX, centerY + size / 2);
          ctx.moveTo(centerX - size / 2, centerY);
          ctx.lineTo(centerX + size / 2, centerY);
          ctx.stroke();

          // Calculate genotypes
          const alleles1 = parent1.split("");
          const alleles2 = parent2.split("");
          const offspring = [];

          for (let a1 of alleles1) {
            for (let a2 of alleles2) {
              offspring.push(a1 + a2);
            }
          }

          // Draw offspring genotypes
          ctx.fillStyle = "#fff";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          const positions = [
            [centerX - size / 4, centerY - size / 4],
            [centerX + size / 4, centerY - size / 4],
            [centerX - size / 4, centerY + size / 4],
            [centerX + size / 4, centerY + size / 4],
          ];

          offspring.forEach((genotype, i) => {
            const [x, y] = positions[i];

            // Color based on phenotype
            let color = "#3b82f6";
            if (trait === "dominant") {
              color = genotype.includes("A") ? "#ef4444" : "#3b82f6";
            } else if (trait === "recessive") {
              color = genotype === "aa" ? "#ef4444" : "#3b82f6";
            }

            ctx.fillStyle = color;
            ctx.fillText(genotype, x, y);
          });

          // Draw parent genotypes
          ctx.fillStyle = "#94a3b8";
          ctx.fillText(parent1, centerX - size / 4, centerY - size / 2 - 20);
          ctx.fillText(parent2, centerX - size / 2 - 20, centerY - size / 4);
        }

        parent1Select.addEventListener("change", drawPunnettSquare);
        parent2Select.addEventListener("change", drawPunnettSquare);
        traitSelect.addEventListener("change", drawPunnettSquare);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["genetics-mendelian-crosses"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 14. Microbiology Simulation
      function initMicrobiology() {
        const canvas = document.getElementById("microbiology-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const nutrientSlider = document.getElementById("nutrient-level");
        const tempSlider = document.getElementById("culture-temperature");
        const timeDisplay = document.getElementById("culture-time");
        const countDisplay = document.getElementById("bacteria-count");

        let bacteria = [];
        let time = 0;
        let population = 10;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          initBacteria();
          drawMicrobiology();
        }

        function initBacteria() {
          bacteria = [];
          for (let i = 0; i < population; i++) {
            bacteria.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              size: 5 + Math.random() * 3,
              divisionTimer: Math.random() * 100,
            });
          }
        }

        function drawMicrobiology() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const nutrients = parseFloat(nutrientSlider.value);
          const temperature = parseFloat(tempSlider.value);

          // Draw culture medium
          ctx.fillStyle = `rgba(139, 69, 19, ${nutrients / 100})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Update and draw bacteria
          let newBacteria = [];

          bacteria.forEach((bacterium) => {
            // Movement
            bacterium.x += (Math.random() - 0.5) * 2;
            bacterium.y += (Math.random() - 0.5) * 2;

            // Keep in bounds
            bacterium.x = Math.max(5, Math.min(canvas.width - 5, bacterium.x));
            bacterium.y = Math.max(5, Math.min(canvas.height - 5, bacterium.y));

            // Growth and division
            bacterium.divisionTimer -= (temperature / 37) * (nutrients / 50);
            bacterium.size += 0.01 * (nutrients / 50);

            if (bacterium.divisionTimer <= 0 && bacterium.size > 8) {
              // Cell division
              newBacteria.push({
                x: bacterium.x + 10,
                y: bacterium.y + 10,
                size: 5,
                divisionTimer: 100,
              });
              bacterium.size = 5;
              bacterium.divisionTimer = 100;
            }

            // Draw bacterium
            ctx.fillStyle =
              temperature > 40
                ? "#ef4444"
                : temperature < 30
                ? "#3b82f6"
                : "#10b981";
            ctx.beginPath();
            ctx.arc(bacterium.x, bacterium.y, bacterium.size, 0, Math.PI * 2);
            ctx.fill();
          });

          // Add new bacteria
          bacteria = bacteria.concat(newBacteria);
          population = bacteria.length;

          // Update time
          time += 0.1;

          timeDisplay.textContent = time.toFixed(1);
          countDisplay.textContent = population;

          if (simulationInstances["microbiology-virtual-culture"].running) {
            simulationInstances[
              "microbiology-virtual-culture"
            ].animationFrameId = requestAnimationFrame(drawMicrobiology);
          }
        }

        function startCulture() {
          simulationInstances["microbiology-virtual-culture"].running = true;
          drawMicrobiology();
        }

        function stopCulture() {
          simulationInstances["microbiology-virtual-culture"].running = false;
          if (
            simulationInstances["microbiology-virtual-culture"].animationFrameId
          ) {
            cancelAnimationFrame(
              simulationInstances["microbiology-virtual-culture"]
                .animationFrameId
            );
          }
        }

        nutrientSlider.addEventListener("input", drawMicrobiology);
        tempSlider.addEventListener("input", drawMicrobiology);

        document
          .getElementById("start-culture")
          ?.addEventListener("click", startCulture);
        document
          .getElementById("stop-culture")
          ?.addEventListener("click", stopCulture);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["microbiology-virtual-culture"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 15. Bioinformatics Simulation
      function initBioinformatics() {
        const canvas = document.getElementById("bioinformatics-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const sequenceInput = document.getElementById("dna-sequence");
        const analysisTypeSelect = document.getElementById("analysis-type");
        const resultDisplay = document.getElementById("analysis-result");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawSequence();
        }

        function drawSequence() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const sequence = sequenceInput.value.toUpperCase() || "ATCGATCGATCG";
          const analysisType = analysisTypeSelect.value;

          const baseColors = {
            A: "#ef4444", // Red
            T: "#3b82f6", // Blue
            C: "#10b981", // Green
            G: "#f59e0b", // Yellow
          };

          const baseWidth = Math.min(30, canvas.width / sequence.length);
          const startX = (canvas.width - sequence.length * baseWidth) / 2;
          const centerY = canvas.height / 2;

          // Draw DNA sequence
          for (let i = 0; i < sequence.length; i++) {
            const base = sequence[i];
            const x = startX + i * baseWidth;

            if (baseColors[base]) {
              ctx.fillStyle = baseColors[base];
              ctx.fillRect(x, centerY - 20, baseWidth - 2, 40);

              // Base label
              ctx.fillStyle = "#fff";
              ctx.font = "12px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(base, x + baseWidth / 2, centerY);
            }
          }

          // Perform analysis
          let result = "";
          if (analysisType === "gc-content") {
            const gcCount = (sequence.match(/[GC]/g) || []).length;
            const gcContent = ((gcCount / sequence.length) * 100).toFixed(1);
            result = `GC Content: ${gcContent}%`;
          } else if (analysisType === "base-count") {
            const counts = {};
            for (let base of ["A", "T", "C", "G"]) {
              counts[base] = (
                sequence.match(new RegExp(base, "g")) || []
              ).length;
            }
            result = `A:${counts.A} T:${counts.T} C:${counts.C} G:${counts.G}`;
          }

          resultDisplay.textContent = result;
        }

        sequenceInput.addEventListener("input", drawSequence);
        analysisTypeSelect.addEventListener("change", drawSequence);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["bioinformatics-dna-sequence"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 16. Water Quality Testing
      function initWaterQuality() {
        const canvas = document.getElementById("waterquality-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const phSlider = document.getElementById("water-ph");
        const turbiditySlider = document.getElementById("turbidity");
        const dissolvedOxygenSlider =
          document.getElementById("dissolved-oxygen");
        const temperatureSlider = document.getElementById("water-temperature");
        const qualityDisplay = document.getElementById("water-quality");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          drawWaterQuality();
        }

        function drawWaterQuality() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const pH = parseFloat(phSlider.value);
          const turbidity = parseFloat(turbiditySlider.value);
          const dissolvedOxygen = parseFloat(dissolvedOxygenSlider.value);
          const temperature = parseFloat(temperatureSlider.value);

          // Calculate water quality index (simplified)
          let qualityScore = 100;

          // pH effect (optimal 6.5-8.5)
          const phDeviation = Math.max(Math.abs(pH - 6.5), Math.abs(pH - 8.5));
          qualityScore -= phDeviation * 10;

          // Turbidity effect
          qualityScore -= turbidity * 0.5;

          // Dissolved oxygen effect
          qualityScore -= Math.max(0, 8 - dissolvedOxygen) * 5;

          // Temperature effect
          qualityScore -= Math.abs(temperature - 20) * 2;

          qualityScore = Math.max(0, Math.min(100, qualityScore));

          // Draw water body
          const waterColor = getWaterColor(turbidity, pH);
          ctx.fillStyle = waterColor;
          ctx.fillRect(50, 100, canvas.width - 100, canvas.height - 150);

          // Draw indicators
          drawIndicator(100, 50, pH, "pH", "#ef4444");
          drawIndicator(200, 50, turbidity, "Turbidity", "#8b5a2b");
          drawIndicator(300, 50, dissolvedOxygen, "DO", "#3b82f6");
          drawIndicator(400, 50, temperature, "Temp", "#f59e0b");

          // Draw aquatic life based on quality
          drawAquaticLife(qualityScore);

          // Quality rating
          let rating = "Excellent";
          let ratingColor = "#10b981";

          if (qualityScore < 60) {
            rating = "Poor";
            ratingColor = "#ef4444";
          } else if (qualityScore < 80) {
            rating = "Fair";
            ratingColor = "#f59e0b";
          } else if (qualityScore < 90) {
            rating = "Good";
            ratingColor = "#84cc16";
          }

          qualityDisplay.textContent = `${rating} (${qualityScore.toFixed(
            0
          )}/100)`;
          qualityDisplay.style.color = ratingColor;
        }

        function getWaterColor(turbidity, pH) {
          // Base blue color
          let r = 64,
            g = 156,
            b = 255;

          // Adjust for turbidity (more brown)
          r += turbidity * 2;
          g += turbidity * 1.5;
          b -= turbidity * 0.5;

          // Adjust for pH (more green for basic, more red for acidic)
          if (pH > 7) {
            g += (pH - 7) * 10;
          } else {
            r += (7 - pH) * 10;
          }

          return `rgb(${Math.min(255, r)}, ${Math.min(255, g)}, ${Math.min(
            255,
            b
          )})`;
        }

        function drawIndicator(x, y, value, label, color) {
          // Draw gauge
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(x, y, 20, -Math.PI, 0);
          ctx.stroke();

          // Draw needle
          const angle = -Math.PI + (value / 100) * Math.PI;
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(angle) * 15, y + Math.sin(angle) * 15);
          ctx.stroke();

          // Draw label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(label, x, y + 30);
        }

        function drawAquaticLife(qualityScore) {
          const numFish = Math.floor(qualityScore / 20);

          for (let i = 0; i < numFish; i++) {
            const x = 100 + i * 60;
            const y = 150 + Math.sin(i) * 30;

            ctx.fillStyle =
              qualityScore > 80
                ? "#3b82f6"
                : qualityScore > 60
                ? "#f59e0b"
                : "#ef4444";

            // Draw simple fish
            ctx.beginPath();
            ctx.ellipse(x, y, 15, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.beginPath();
            ctx.moveTo(x - 15, y);
            ctx.lineTo(x - 25, y - 8);
            ctx.lineTo(x - 25, y + 8);
            ctx.closePath();
            ctx.fill();
          }
        }

        phSlider.addEventListener("input", drawWaterQuality);
        turbiditySlider.addEventListener("input", drawWaterQuality);
        dissolvedOxygenSlider.addEventListener("input", drawWaterQuality);
        temperatureSlider.addEventListener("input", drawWaterQuality);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["water-quality-testing"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 17. Carbon Cycle Simulation
      function initCarbonCycle() {
        const canvas = document.getElementById("carboncycle-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const emissionSlider = document.getElementById("emission-rate");
        const absorptionSlider = document.getElementById("absorption-rate");
        const deforestationSlider =
          document.getElementById("deforestation-rate");
        const co2Display = document.getElementById("co2-level");
        const tempDisplay = document.getElementById("temperature-rise");

        let carbonPools = {
          atmosphere: 800,
          ocean: 38000,
          vegetation: 600,
          soil: 1500,
          fossil: 4000,
        };

        let fluxes = {
          respiration: 60,
          photosynthesis: 58,
          oceanExchange: 90,
          fossilEmissions: 8,
          deforestation: 2,
        };

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawCarbonCycle();
        }

        function drawCarbonCycle() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const emissions = parseFloat(emissionSlider.value);
          const absorption = parseFloat(absorptionSlider.value);
          const deforestation = parseFloat(deforestationSlider.value);

          // Update fluxes based on controls
          fluxes.fossilEmissions = emissions;
          fluxes.photosynthesis = absorption;
          fluxes.deforestation = deforestation;

          // Simple carbon cycle model
          carbonPools.atmosphere +=
            fluxes.fossilEmissions + fluxes.respiration + fluxes.deforestation;
          carbonPools.atmosphere -=
            fluxes.photosynthesis + fluxes.oceanExchange;

          carbonPools.vegetation += fluxes.photosynthesis;
          carbonPools.vegetation -= fluxes.respiration + fluxes.deforestation;

          carbonPools.ocean += fluxes.oceanExchange;

          // Ensure values stay reasonable
          carbonPools.atmosphere = Math.max(
            600,
            Math.min(1200, carbonPools.atmosphere)
          );
          carbonPools.vegetation = Math.max(
            400,
            Math.min(800, carbonPools.vegetation)
          );

          // Draw carbon pools
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;

          // Atmosphere (top)
          drawCarbonPool(
            centerX,
            80,
            carbonPools.atmosphere,
            "Atmosphere",
            "#3b82f6"
          );

          // Vegetation (left)
          drawCarbonPool(
            centerX - 150,
            centerY,
            carbonPools.vegetation,
            "Vegetation",
            "#10b981"
          );

          // Ocean (right)
          drawCarbonPool(
            centerX + 150,
            centerY,
            carbonPools.ocean,
            "Ocean",
            "#0ea5e9"
          );

          // Soil (bottom left)
          drawCarbonPool(
            centerX - 100,
            centerY + 100,
            carbonPools.soil,
            "Soil",
            "#8b5a2b"
          );

          // Fossil fuels (bottom right)
          drawCarbonPool(
            centerX + 100,
            centerY + 100,
            carbonPools.fossil,
            "Fossil Fuels",
            "#475569"
          );

          // Draw fluxes (arrows)
          drawFlux(
            centerX,
            100,
            centerX - 150,
            centerY - 30,
            fluxes.photosynthesis,
            "Photosynthesis",
            "#84cc16"
          );
          drawFlux(
            centerX - 150,
            centerY + 30,
            centerX,
            120,
            fluxes.respiration,
            "Respiration",
            "#ef4444"
          );
          drawFlux(
            centerX,
            120,
            centerX + 150,
            centerY - 30,
            fluxes.oceanExchange,
            "Ocean Exchange",
            "#3b82f6"
          );
          drawFlux(
            centerX + 100,
            centerY + 80,
            centerX,
            120,
            fluxes.fossilEmissions,
            "Emissions",
            "#f59e0b"
          );
          drawFlux(
            centerX - 150,
            centerY + 30,
            centerX,
            120,
            fluxes.deforestation,
            "Deforestation",
            "#dc2626"
          );

          // Calculate climate impact
          const co2Increase = ((carbonPools.atmosphere - 800) / 800) * 100;
          const tempIncrease = co2Increase * 0.01; // Simplified climate sensitivity

          co2Display.textContent = `${co2Increase.toFixed(1)}%`;
          tempDisplay.textContent = `${tempIncrease.toFixed(2)}°C`;

          if (simulationInstances["carbon-cycle-climate-modeling"].running) {
            simulationInstances[
              "carbon-cycle-climate-modeling"
            ].animationFrameId = requestAnimationFrame(drawCarbonCycle);
          }
        }

        function drawCarbonPool(x, y, amount, label, color) {
          const size = Math.sqrt(amount) * 0.5;

          ctx.fillStyle = color + "80";
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.stroke();

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(label, x, y + size + 20);
          ctx.fillText(Math.round(amount), x, y);
        }

        function drawFlux(fromX, fromY, toX, toY, amount, label, color) {
          if (amount <= 0) return;

          ctx.strokeStyle = color;
          ctx.lineWidth = Math.min(5, amount / 10);
          ctx.beginPath();
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);
          ctx.stroke();

          // Arrow head
          const angle = Math.atan2(toY - fromY, toX - fromX);
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.moveTo(toX, toY);
          ctx.lineTo(
            toX - 10 * Math.cos(angle - Math.PI / 6),
            toY - 10 * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            toX - 10 * Math.cos(angle + Math.PI / 6),
            toY - 10 * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fill();

          // Label
          const midX = (fromX + toX) / 2;
          const midY = (fromY + toY) / 2;
          ctx.fillStyle = "#fff";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          ctx.fillText(label, midX, midY - 10);
        }

        function startCarbonCycle() {
          simulationInstances["carbon-cycle-climate-modeling"].running = true;
          drawCarbonCycle();
        }

        function stopCarbonCycle() {
          simulationInstances["carbon-cycle-climate-modeling"].running = false;
          if (
            simulationInstances["carbon-cycle-climate-modeling"]
              .animationFrameId
          ) {
            cancelAnimationFrame(
              simulationInstances["carbon-cycle-climate-modeling"]
                .animationFrameId
            );
          }
        }

        emissionSlider.addEventListener("input", drawCarbonCycle);
        absorptionSlider.addEventListener("input", drawCarbonCycle);
        deforestationSlider.addEventListener("input", drawCarbonCycle);

        document
          .getElementById("start-carbon-cycle")
          ?.addEventListener("click", startCarbonCycle);
        document
          .getElementById("stop-carbon-cycle")
          ?.addEventListener("click", stopCarbonCycle);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["carbon-cycle-climate-modeling"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 18. Soil Analysis Simulation
      function initSoilAnalysis() {
        const canvas = document.getElementById("soilanalysis-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const phSlider = document.getElementById("soil-ph");
        const nitrogenSlider = document.getElementById("nitrogen-level");
        const moistureSlider = document.getElementById("moisture-level");
        const organicSlider = document.getElementById("organic-matter");
        const growthDisplay = document.getElementById("plant-growth");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawSoilAnalysis();
        }

        function drawSoilAnalysis() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const pH = parseFloat(phSlider.value);
          const nitrogen = parseFloat(nitrogenSlider.value);
          const moisture = parseFloat(moistureSlider.value);
          const organicMatter = parseFloat(organicSlider.value);

          // Draw soil profile
          const profileWidth = canvas.width - 100;
          const profileHeight = 200;
          const profileX = 50;
          const profileY = canvas.height - profileHeight - 50;

          // Soil layers based on properties
          drawSoilLayer(
            profileX,
            profileY,
            profileWidth,
            60,
            "Topsoil",
            getSoilColor(pH, organicMatter)
          );
          drawSoilLayer(
            profileX,
            profileY + 60,
            profileWidth,
            80,
            "Subsoil",
            getSoilColor(pH, organicMatter * 0.7)
          );
          drawSoilLayer(
            profileX,
            profileY + 140,
            profileWidth,
            60,
            "Bedrock",
            "#8b5a2b"
          );

          // Draw plants based on soil quality
          const growthQuality = calculateGrowthQuality(
            pH,
            nitrogen,
            moisture,
            organicMatter
          );
          drawPlants(growthQuality, profileX, profileY, profileWidth);

          // Draw soil indicators
          drawSoilIndicator(100, 50, pH, "pH", "#ef4444");
          drawSoilIndicator(200, 50, nitrogen, "Nitrogen", "#10b981");
          drawSoilIndicator(300, 50, moisture, "Moisture", "#3b82f6");
          drawSoilIndicator(400, 50, organicMatter, "Organic", "#8b5a2b");

          growthDisplay.textContent = `${growthQuality.toFixed(0)}%`;
        }

        function getSoilColor(pH, organicMatter) {
          // Base brown color
          let r = 139,
            g = 69,
            b = 19;

          // Adjust for pH (more red for acidic, more yellow for basic)
          if (pH < 7) {
            r += (7 - pH) * 10;
          } else {
            g += (pH - 7) * 10;
          }

          // Adjust for organic matter (darker)
          r -= organicMatter * 0.5;
          g -= organicMatter * 0.3;
          b -= organicMatter * 0.2;

          return `rgb(${Math.max(0, r)}, ${Math.max(0, g)}, ${Math.max(0, b)})`;
        }

        function drawSoilLayer(x, y, width, height, label, color) {
          ctx.fillStyle = color;
          ctx.fillRect(x, y, width, height);

          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, width, height);

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "left";
          ctx.fillText(label, x + 10, y + 20);
        }

        function drawSoilIndicator(x, y, value, label, color) {
          // Draw gauge bar
          ctx.fillStyle = "#374151";
          ctx.fillRect(x, y, 60, 10);

          ctx.fillStyle = color;
          ctx.fillRect(x, y, (value / 100) * 60, 10);

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(label, x + 30, y + 25);
          ctx.fillText(value.toFixed(0), x + 30, y - 5);
        }

        function calculateGrowthQuality(pH, nitrogen, moisture, organicMatter) {
          let quality = 100;

          // pH effect (optimal 6-7)
          quality -= Math.abs(pH - 6.5) * 10;

          // Nutrient effects
          quality -= Math.max(0, 50 - nitrogen) * 0.5;
          quality -= Math.max(0, 60 - moisture) * 0.5;
          quality -= Math.max(0, 30 - organicMatter) * 0.5;

          return Math.max(0, Math.min(100, quality));
        }

        function drawPlants(growthQuality, soilX, soilY, soilWidth) {
          const numPlants = Math.floor(growthQuality / 20);
          const plantHeight = growthQuality * 0.5;

          for (let i = 0; i < numPlants; i++) {
            const x = soilX + (i + 1) * (soilWidth / (numPlants + 1));
            const y = soilY - plantHeight;

            // Stem
            ctx.strokeStyle = "#10b981";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, soilY);
            ctx.lineTo(x, y);
            ctx.stroke();

            // Leaves
            ctx.fillStyle = "#22c55e";
            ctx.beginPath();
            ctx.ellipse(x - 10, y + 20, 8, 15, -Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 10, y + 20, 8, 15, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            // Flower if high quality
            if (growthQuality > 80) {
              ctx.fillStyle = "#f59e0b";
              ctx.beginPath();
              ctx.arc(x, y, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }

        phSlider.addEventListener("input", drawSoilAnalysis);
        nitrogenSlider.addEventListener("input", drawSoilAnalysis);
        moistureSlider.addEventListener("input", drawSoilAnalysis);
        organicSlider.addEventListener("input", drawSoilAnalysis);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["soil-analysis-plant-growth"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 19. Renewable Energy Simulation
      function initRenewableEnergy() {
        const canvas = document.getElementById("renewableenergy-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const solarSlider = document.getElementById("solar-capacity");
        const windSlider = document.getElementById("wind-capacity");
        const hydroSlider = document.getElementById("hydro-capacity");
        const demandSlider = document.getElementById("energy-demand");
        const outputDisplay = document.getElementById("energy-output");
        const coverageDisplay = document.getElementById("demand-coverage");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawRenewableEnergy();
        }

        function drawRenewableEnergy() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const solarCapacity = parseFloat(solarSlider.value);
          const windCapacity = parseFloat(windSlider.value);
          const hydroCapacity = parseFloat(hydroSlider.value);
          const energyDemand = parseFloat(demandSlider.value);

          // Calculate energy production (simplified)
          const solarOutput = solarCapacity * 0.8; // 80% capacity factor
          const windOutput = windCapacity * 0.35; // 35% capacity factor
          const hydroOutput = hydroCapacity * 0.5; // 50% capacity factor
          const totalOutput = solarOutput + windOutput + hydroOutput;

          const demandCoverage = Math.min(
            100,
            (totalOutput / energyDemand) * 100
          );

          // Draw power plant
          const centerX = canvas.width / 2;

          // Solar farm (left)
          drawSolarFarm(centerX - 200, 150, solarCapacity);

          // Wind farm (center)
          drawWindFarm(centerX, 150, windCapacity);

          // Hydro plant (right)
          drawHydroPlant(centerX + 200, 150, hydroCapacity);

          // Draw power grid
          drawPowerGrid(centerX, 300, totalOutput, energyDemand);

          // Draw city (bottom)
          drawCity(centerX, canvas.height - 100, energyDemand, demandCoverage);

          outputDisplay.textContent = totalOutput.toFixed(1);
          coverageDisplay.textContent = `${demandCoverage.toFixed(1)}%`;
        }

        function drawSolarFarm(x, y, capacity) {
          const numPanels = Math.floor(capacity / 10);

          for (let i = 0; i < numPanels; i++) {
            const panelX = x + (i % 5) * 25;
            const panelY = y + Math.floor(i / 5) * 20;

            ctx.fillStyle = "#f59e0b";
            ctx.fillRect(panelX, panelY, 20, 15);

            // Solar rays
            ctx.strokeStyle = "rgba(245, 158, 11, 0.5)";
            ctx.lineWidth = 1;
            for (let j = 0; j < 3; j++) {
              ctx.beginPath();
              ctx.moveTo(panelX + 10, panelY - 10 - j * 5);
              ctx.lineTo(panelX + 5, panelY);
              ctx.lineTo(panelX + 15, panelY);
              ctx.closePath();
              ctx.stroke();
            }
          }

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Solar", x + 50, y + 60);
        }

        function drawWindFarm(x, y, capacity) {
          const numTurbines = Math.floor(capacity / 20);

          for (let i = 0; i < numTurbines; i++) {
            const turbineX = x + (i - (numTurbines - 1) / 2) * 40;

            // Tower
            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(turbineX, y + 50);
            ctx.lineTo(turbineX, y);
            ctx.stroke();

            // Blades
            ctx.strokeStyle = "#cbd5e1";
            ctx.lineWidth = 2;
            for (let j = 0; j < 3; j++) {
              const angle = (j / 3) * Math.PI * 2 + Date.now() / 1000;
              ctx.beginPath();
              ctx.moveTo(turbineX, y);
              ctx.lineTo(
                turbineX + Math.cos(angle) * 20,
                y + Math.sin(angle) * 20
              );
              ctx.stroke();
            }
          }

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Wind", x, y + 80);
        }

        function drawHydroPlant(x, y, capacity) {
          // Dam
          ctx.fillStyle = "#475569";
          ctx.fillRect(x - 30, y, 60, 40);

          // Reservoir
          ctx.fillStyle = "#3b82f6";
          ctx.fillRect(x - 100, y - 30, 70, 30);

          // Water flow
          ctx.strokeStyle = "#3b82f6";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x, y + 40);
          ctx.lineTo(x, y + 70);
          ctx.stroke();

          // Turbine house
          ctx.fillStyle = "#64748b";
          ctx.fillRect(x - 20, y + 40, 40, 20);

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Hydro", x, y + 80);
        }

        function drawPowerGrid(centerX, y, output, demand) {
          // Power lines
          ctx.strokeStyle = "#f59e0b";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX - 200, y);
          ctx.lineTo(centerX + 200, y);
          ctx.stroke();

          // Draw power flow indicators
          const flowIntensity = Math.min(1, output / demand);
          ctx.strokeStyle = `rgba(245, 158, 11, ${flowIntensity})`;
          ctx.lineWidth = 4;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(centerX - 200, y);
          ctx.lineTo(centerX + 200, y);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        function drawCity(centerX, y, demand, coverage) {
          // City skyline
          const buildingHeights = [40, 60, 30, 50, 35, 45];
          const buildingWidth = 30;

          for (let i = 0; i < buildingHeights.length; i++) {
            const buildingX =
              centerX -
              (buildingHeights.length * buildingWidth) / 2 +
              i * buildingWidth;
            const height = buildingHeights[i];

            ctx.fillStyle =
              coverage > 80 ? "#3b82f6" : coverage > 50 ? "#f59e0b" : "#ef4444";
            ctx.fillRect(buildingX, y - height, buildingWidth - 2, height);

            // Windows
            ctx.fillStyle = "#fbbf24";
            for (let floor = 0; floor < height / 10; floor++) {
              for (let window = 0; window < 2; window++) {
                if (Math.random() < 0.7) {
                  // Random lit windows
                  ctx.fillRect(
                    buildingX + 5 + window * 10,
                    y - height + 5 + floor * 10,
                    8,
                    8
                  );
                }
              }
            }
          }

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText("City", centerX, y + 20);
        }

        solarSlider.addEventListener("input", drawRenewableEnergy);
        windSlider.addEventListener("input", drawRenewableEnergy);
        hydroSlider.addEventListener("input", drawRenewableEnergy);
        demandSlider.addEventListener("input", drawRenewableEnergy);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["renewable-energy-site-analysis"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 20. Population Dynamics Simulation
      function initPopulationDynamics() {
        const canvas = document.getElementById("population-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const preySlider = document.getElementById("prey-population");
        const predatorSlider = document.getElementById("predator-population");
        const foodSlider = document.getElementById("food-availability");
        const timeDisplay = document.getElementById("simulation-time");

        let preyPopulation = 100;
        let predatorPopulation = 20;
        let foodAvailability = 50;
        let time = 0;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawPopulationDynamics();
        }

        function drawPopulationDynamics() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const initialPrey = parseFloat(preySlider.value);
          const initialPredator = parseFloat(predatorSlider.value);
          foodAvailability = parseFloat(foodSlider.value);

          // Draw environment background
          ctx.fillStyle = `rgba(34, 197, 94, ${foodAvailability / 100})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Update populations using Lotka-Volterra equations (simplified)
          const preyGrowth = preyPopulation * (foodAvailability / 100) * 0.1;
          const predationRate = 0.01 * preyPopulation * predatorPopulation;
          const predatorGrowth = predationRate * 0.3;
          const predatorDeath = predatorPopulation * 0.05;

          preyPopulation += preyGrowth - predationRate;
          predatorPopulation += predatorGrowth - predatorDeath;

          // Ensure populations don't go extinct or explode
          preyPopulation = Math.max(10, Math.min(500, preyPopulation));
          predatorPopulation = Math.max(5, Math.min(100, predatorPopulation));

          // Draw prey animals (green)
          const numPrey = Math.floor(preyPopulation / 10);
          for (let i = 0; i < numPrey; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;

            ctx.fillStyle = "#10b981";
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw predator animals (red)
          const numPredators = Math.floor(predatorPopulation / 2);
          for (let i = 0; i < numPredators; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;

            ctx.fillStyle = "#ef4444";
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();

            // Draw predator features
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 8, y);
            ctx.lineTo(x + 12, y);
            ctx.stroke();
          }

          // Draw population graphs
          drawPopulationGraph();

          time += 0.1;
          timeDisplay.textContent = time.toFixed(1);

          if (simulationInstances["ecological-population-dynamics"].running) {
            simulationInstances[
              "ecological-population-dynamics"
            ].animationFrameId = requestAnimationFrame(drawPopulationDynamics);
          }
        }

        function drawPopulationGraph() {
          const graphWidth = 300;
          const graphHeight = 100;
          const graphX = canvas.width - graphWidth - 20;
          const graphY = 20;

          // Draw graph background
          ctx.fillStyle = "rgba(30, 41, 59, 0.8)";
          ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
          ctx.strokeStyle = "#94a3b8";
          ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);

          // Draw prey population line (green)
          ctx.strokeStyle = "#10b981";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(
            graphX,
            graphY + graphHeight - (preyPopulation / 500) * graphHeight
          );
          ctx.lineTo(
            graphX + graphWidth,
            graphY + graphHeight - (preyPopulation / 500) * graphHeight
          );
          ctx.stroke();

          // Draw predator population line (red)
          ctx.strokeStyle = "#ef4444";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(
            graphX,
            graphY + graphHeight - (predatorPopulation / 100) * graphHeight
          );
          ctx.lineTo(
            graphX + graphWidth,
            graphY + graphHeight - (predatorPopulation / 100) * graphHeight
          );
          ctx.stroke();

          // Labels
          ctx.fillStyle = "#fff";
          ctx.font = "10px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            `Prey: ${Math.round(preyPopulation)}`,
            graphX + 5,
            graphY + 15
          );
          ctx.fillText(
            `Predators: ${Math.round(predatorPopulation)}`,
            graphX + 5,
            graphY + 30
          );
        }

        function startPopulationSim() {
          preyPopulation = parseFloat(preySlider.value);
          predatorPopulation = parseFloat(predatorSlider.value);
          time = 0;
          simulationInstances["ecological-population-dynamics"].running = true;
          drawPopulationDynamics();
        }

        function stopPopulationSim() {
          simulationInstances["ecological-population-dynamics"].running = false;
          if (
            simulationInstances["ecological-population-dynamics"]
              .animationFrameId
          ) {
            cancelAnimationFrame(
              simulationInstances["ecological-population-dynamics"]
                .animationFrameId
            );
          }
        }

        preySlider.addEventListener("input", drawPopulationDynamics);
        predatorSlider.addEventListener("input", drawPopulationDynamics);
        foodSlider.addEventListener("input", drawPopulationDynamics);

        document
          .getElementById("start-population")
          ?.addEventListener("click", startPopulationSim);
        document
          .getElementById("stop-population")
          ?.addEventListener("click", stopPopulationSim);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["ecological-population-dynamics"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 21. Breadboard Circuit Builder
      function initBreadboard() {
        const canvas = document.getElementById("breadboard-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const componentSelect = document.getElementById("circuit-component");
        const voltageSlider = document.getElementById("circuit-voltage");
        const currentDisplay = document.getElementById("circuit-current");
        const statusDisplay = document.getElementById("circuit-status");

        let components = [];
        let wires = [];
        let selectedComponent = null;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawBreadboard();
        }

        function drawBreadboard() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw breadboard background
          ctx.fillStyle = "#1e293b";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Draw breadboard holes
          const holeSpacing = 20;
          const holeRadius = 2;

          ctx.fillStyle = "#374151";
          for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 40; col++) {
              const x = 50 + col * holeSpacing;
              const y = 50 + row * holeSpacing;

              // Different color for power rails
              if (row < 2 || row >= 18) {
                ctx.fillStyle = "#ef4444";
              } else if (row >= 9 && row < 11) {
                ctx.fillStyle = "#64748b";
              } else {
                ctx.fillStyle = "#475569";
              }

              ctx.beginPath();
              ctx.arc(x, y, holeRadius, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // Draw components
          components.forEach((component) => {
            drawComponent(component);
          });

          // Draw wires
          wires.forEach((wire) => {
            drawWire(wire);
          });

          // Calculate circuit status
          const voltage = parseFloat(voltageSlider.value);
          let totalResistance = 0;
          let hasBattery = false;

          components.forEach((comp) => {
            if (comp.type === "resistor") totalResistance += comp.value;
            if (comp.type === "battery") hasBattery = true;
          });

          const current =
            hasBattery && totalResistance > 0 ? voltage / totalResistance : 0;

          currentDisplay.textContent = current.toFixed(3);
          statusDisplay.textContent = hasBattery
            ? current > 0
              ? "Circuit Complete"
              : "Open Circuit"
            : "No Power Source";
          statusDisplay.style.color =
            hasBattery && current > 0 ? "#10b981" : "#ef4444";
        }

        function drawComponent(component) {
          const x = component.x;
          const y = component.y;

          ctx.strokeStyle =
            component === selectedComponent ? "#f59e0b" : "#94a3b8";
          ctx.lineWidth = component === selectedComponent ? 3 : 2;
          ctx.fillStyle = getComponentColor(component.type);

          switch (component.type) {
            case "resistor":
              // Draw resistor body
              ctx.fillRect(x - 15, y - 5, 30, 10);
              ctx.strokeRect(x - 15, y - 5, 30, 10);

              // Draw value
              ctx.fillStyle = "#fff";
              ctx.font = "10px Arial";
              ctx.textAlign = "center";
              ctx.fillText(`${component.value}Ω`, x, y - 10);
              break;

            case "led":
              // Draw LED
              ctx.beginPath();
              ctx.arc(x, y, 8, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();

              // Draw anode and cathode
              ctx.strokeStyle = "#fff";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(x - 12, y);
              ctx.lineTo(x - 8, y);
              ctx.moveTo(x + 8, y);
              ctx.lineTo(x + 12, y);
              ctx.stroke();
              break;

            case "battery":
              // Draw battery
              ctx.fillRect(x - 10, y - 20, 20, 40);
              ctx.strokeRect(x - 10, y - 20, 20, 40);

              // Draw terminals
              ctx.fillRect(x - 5, y - 25, 10, 5);
              ctx.fillRect(x - 3, y + 20, 6, 5);
              break;

            case "capacitor":
              // Draw capacitor
              ctx.strokeRect(x - 12, y - 8, 24, 16);
              ctx.beginPath();
              ctx.moveTo(x - 12, y - 2);
              ctx.lineTo(x - 20, y - 2);
              ctx.moveTo(x - 12, y + 2);
              ctx.lineTo(x - 20, y + 2);
              ctx.moveTo(x + 12, y - 2);
              ctx.lineTo(x + 20, y - 2);
              ctx.moveTo(x + 12, y + 2);
              ctx.lineTo(x + 20, y + 2);
              ctx.stroke();
              break;
          }
        }

        function getComponentColor(type) {
          const colors = {
            resistor: "#8b5a2b",
            led: "#10b981",
            battery: "#f59e0b",
            capacitor: "#3b82f6",
          };
          return colors[type] || "#94a3b8";
        }

        function drawWire(wire) {
          ctx.strokeStyle = "#f59e0b";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(wire.fromX, wire.fromY);
          ctx.lineTo(wire.toX, wire.toY);
          ctx.stroke();
        }

        function addComponent(type, value = 100) {
          const x = 100 + Math.random() * (canvas.width - 200);
          const y = 100 + Math.random() * (canvas.height - 200);

          components.push({
            type: type,
            value: value,
            x: x,
            y: y,
          });

          drawBreadboard();
        }

        function clearCircuit() {
          components = [];
          wires = [];
          drawBreadboard();
        }

        // Event listeners for component buttons
        document
          .getElementById("add-resistor")
          ?.addEventListener("click", () => addComponent("resistor", 100));
        document
          .getElementById("add-led")
          ?.addEventListener("click", () => addComponent("led"));
        document
          .getElementById("add-battery")
          ?.addEventListener("click", () => addComponent("battery", 9));
        document
          .getElementById("add-capacitor")
          ?.addEventListener("click", () => addComponent("capacitor", 100));
        document
          .getElementById("clear-circuit")
          ?.addEventListener("click", clearCircuit);

        voltageSlider.addEventListener("input", drawBreadboard);

        // Component selection on click
        canvas.addEventListener("click", (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          selectedComponent = null;
          components.forEach((component) => {
            const dx = component.x - x;
            const dy = component.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 20) {
              selectedComponent = component;
            }
          });

          drawBreadboard();
        });

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["breadboard-circuit-builder"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 22. Microcontroller Programming
      function initMicrocontroller() {
        const canvas = document.getElementById("microcontroller-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const codeInput = document.getElementById("arduino-code");
        const sensorSelect = document.getElementById("sensor-type");
        const outputDisplay = document.getElementById("program-output");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawMicrocontroller();
        }

        function drawMicrocontroller() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const code = codeInput.value;
          const sensorType = sensorSelect.value;

          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;

          // Draw Arduino board
          ctx.fillStyle = "#00979d";
          ctx.fillRect(centerX - 80, centerY - 60, 160, 120);

          // Draw microcontroller chip
          ctx.fillStyle = "#000";
          ctx.fillRect(centerX - 20, centerY - 20, 40, 40);

          // Draw pins
          ctx.fillStyle = "#333";
          for (let i = 0; i < 14; i++) {
            // Digital pins (right side)
            ctx.fillRect(centerX + 80, centerY - 60 + i * 8, 10, 6);
            // Analog pins (left side)
            ctx.fillRect(centerX - 90, centerY - 60 + i * 8, 10, 6);
          }

          // Draw power pins
          ctx.fillStyle = "#ef4444";
          ctx.fillRect(centerX - 90, centerY - 60, 10, 6); // 5V
          ctx.fillRect(centerX - 90, centerY - 52, 10, 6); // 3.3V
          ctx.fillStyle = "#000";
          ctx.fillRect(centerX - 90, centerY - 44, 10, 6); // GND

          // Draw connected sensor
          drawSensor(centerX + 120, centerY, sensorType);

          // Draw LED output based on code
          const hasBlink =
            code.includes("blink") || code.includes("digitalWrite");
          drawLED(centerX - 120, centerY, hasBlink);

          // Update output display
          let output = "Ready";
          if (code.includes("Serial.print")) {
            output = `Sensor Reading: ${Math.random() * 100}`;
          } else if (hasBlink) {
            output = "LED Blinking";
          }
          outputDisplay.textContent = output;
        }

        function drawSensor(x, y, type) {
          ctx.fillStyle = "#94a3b8";
          ctx.fillRect(x - 20, y - 15, 40, 30);

          ctx.fillStyle = "#000";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          switch (type) {
            case "temperature":
              ctx.fillText("Temp", x, y);
              break;
            case "light":
              ctx.fillText("Light", x, y);
              break;
            case "motion":
              ctx.fillText("PIR", x, y);
              break;
          }

          // Draw connection to Arduino
          ctx.strokeStyle = "#f59e0b";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x - 20, y);
          ctx.lineTo(x - 40, y);
          ctx.stroke();
        }

        function drawLED(x, y, blinking) {
          const isOn = blinking ? Date.now() % 1000 < 500 : false;

          ctx.fillStyle = isOn ? "#ef4444" : "#7f1d1d";
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1;
          ctx.stroke();

          // Draw glow effect when on
          if (isOn) {
            ctx.fillStyle = "rgba(239, 68, 68, 0.3)";
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        codeInput.addEventListener("input", drawMicrocontroller);
        sensorSelect.addEventListener("change", drawMicrocontroller);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["microcontroller-programming"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 23. Signal Processing Simulation
      function initSignalProcessing() {
        const timeCanvas = document.getElementById("signal-time-canvas");
        const freqCanvas = document.getElementById("signal-freq-canvas");
        if (!timeCanvas || !freqCanvas) return;
        const timeCtx = timeCanvas.getContext("2d");
        const freqCtx = freqCanvas.getContext("2d");

        const signalTypeSelect = document.getElementById("signal-type");
        const frequencySlider = document.getElementById("signal-frequency");
        const amplitudeSlider = document.getElementById("signal-amplitude");
        const noiseSlider = document.getElementById("noise-level");

        function resizeCanvases() {
          [timeCanvas, freqCanvas].forEach((canvas) => {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
          });
          drawSignals();
        }

        function drawSignals() {
          const signalType = signalTypeSelect.value;
          const frequency = parseFloat(frequencySlider.value);
          const amplitude = parseFloat(amplitudeSlider.value);
          const noiseLevel = parseFloat(noiseSlider.value);

          drawTimeDomain(
            timeCtx,
            timeCanvas,
            signalType,
            frequency,
            amplitude,
            noiseLevel
          );
          drawFrequencyDomain(
            freqCtx,
            freqCanvas,
            signalType,
            frequency,
            amplitude
          );
        }

        function drawTimeDomain(ctx, canvas, type, freq, amp, noise) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          ctx.strokeStyle = "#3b82f6";
          ctx.lineWidth = 2;
          ctx.beginPath();

          const points = 200;
          const timeScale = canvas.width / points;

          for (let i = 0; i < points; i++) {
            const x = i * timeScale;
            let y = 0;

            // Calculate signal value
            const time = (i / points) * 4 * Math.PI;

            switch (type) {
              case "sine":
                y = Math.sin(time * freq);
                break;
              case "square":
                y = Math.sign(Math.sin(time * freq));
                break;
              case "triangle":
                y =
                  2 *
                    Math.abs(
                      2 *
                        ((time * freq) / (2 * Math.PI) -
                          Math.floor((time * freq) / (2 * Math.PI) + 0.5))
                    ) -
                  1;
                break;
              case "noise":
                y = Math.random() * 2 - 1;
                break;
            }

            // Apply amplitude and add noise
            y = y * amp + (Math.random() - 0.5) * noise;

            const pixelY = canvas.height / 2 - y * (canvas.height / 3);

            if (i === 0) ctx.moveTo(x, pixelY);
            else ctx.lineTo(x, pixelY);
          }

          ctx.stroke();

          // Draw axes
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height / 2);
          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
        }

        function drawFrequencyDomain(ctx, canvas, type, freq, amp) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw frequency spectrum
          const maxFreq = 10;
          const binWidth = canvas.width / maxFreq;

          ctx.fillStyle = "#10b981";

          // Fundamental frequency
          const fundamentalHeight = amp * canvas.height * 0.8;
          ctx.fillRect(
            freq * binWidth - 5,
            canvas.height - fundamentalHeight,
            10,
            fundamentalHeight
          );

          // Harmonics for non-sine waves
          if (type !== "sine" && type !== "noise") {
            for (let harmonic = 2; harmonic <= 5; harmonic++) {
              const harmonicFreq = freq * harmonic;
              if (harmonicFreq <= maxFreq) {
                const harmonicHeight = fundamentalHeight / harmonic;
                ctx.fillRect(
                  harmonicFreq * binWidth - 3,
                  canvas.height - harmonicHeight,
                  6,
                  harmonicHeight
                );
              }
            }
          }

          // Draw axes
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height);
          ctx.lineTo(canvas.width, canvas.height);
          ctx.stroke();

          // Frequency labels
          ctx.fillStyle = "#fff";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          for (let f = 1; f <= maxFreq; f++) {
            ctx.fillText(f + "Hz", f * binWidth, canvas.height - 5);
          }
        }

        signalTypeSelect.addEventListener("change", drawSignals);
        frequencySlider.addEventListener("input", drawSignals);
        amplitudeSlider.addEventListener("input", drawSignals);
        noiseSlider.addEventListener("input", drawSignals);

        const resizeListener = () => resizeCanvases();
        window.addEventListener("resize", resizeListener);
        simulationInstances["signal-processing-adc-fft"].resizeListener =
          resizeListener;

        resizeCanvases();
      }

      // 24. Wireless Communication Simulation
      function initWirelessComm() {
        const canvas = document.getElementById("wireless-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const protocolSelect = document.getElementById("protocol-type");
        const distanceSlider = document.getElementById("transmission-distance");
        const powerSlider = document.getElementById("transmission-power");
        const dataDisplay = document.getElementById("data-rate");
        const rangeDisplay = document.getElementById("effective-range");

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawWirelessCommunication();
        }

        function drawWirelessCommunication() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const protocol = protocolSelect.value;
          const distance = parseFloat(distanceSlider.value);
          const power = parseFloat(powerSlider.value);

          const centerX = canvas.width / 2;

          // Draw transmitter
          drawDevice(
            centerX - 200,
            canvas.height / 2,
            "Transmitter",
            "#3b82f6"
          );

          // Draw receiver
          drawDevice(centerX + 200, canvas.height / 2, "Receiver", "#10b981");

          // Draw wireless signal
          drawSignal(
            centerX - 200,
            centerX + 200,
            canvas.height / 2,
            protocol,
            distance,
            power
          );

          // Calculate and display metrics
          const protocolRanges = {
            wifi: { range: 50, dataRate: 100 },
            bluetooth: { range: 10, dataRate: 2 },
            lora: { range: 1000, dataRate: 0.05 },
            zigbee: { range: 20, dataRate: 0.25 },
          };

          const specs = protocolRanges[protocol];
          const effectiveRange = specs.range * (power / 100);
          const dataRate = specs.dataRate * (1 - distance / effectiveRange);

          dataDisplay.textContent =
            dataRate > 0 ? `${dataRate.toFixed(2)} Mbps` : "No Signal";
          rangeDisplay.textContent = `${effectiveRange.toFixed(0)}m`;
        }

        function drawDevice(x, y, label, color) {
          // Draw device body
          ctx.fillStyle = color;
          ctx.fillRect(x - 25, y - 15, 50, 30);

          // Draw antenna
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y - 15);
          ctx.lineTo(x, y - 35);
          ctx.stroke();

          // Label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(label, x, y + 40);
        }

        function drawSignal(fromX, toX, y, protocol, distance, power) {
          const signalStrength =
            Math.max(0, 1 - distance / 100) * (power / 100);

          if (signalStrength > 0) {
            ctx.strokeStyle = getProtocolColor(protocol);
            ctx.lineWidth = 2;
            ctx.setLineDash(getProtocolPattern(protocol));

            // Draw signal waves
            const numWaves = 5;
            const amplitude = 30 * signalStrength;
            const wavelength = (toX - fromX) / numWaves;

            ctx.beginPath();
            for (let x = fromX; x <= toX; x++) {
              const waveX = x - fromX;
              const waveY =
                y + Math.sin((waveX / wavelength) * Math.PI * 2) * amplitude;

              if (x === fromX) ctx.moveTo(x, waveY);
              else ctx.lineTo(x, waveY);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw data packets
            if (signalStrength > 0.3) {
              drawDataPackets(fromX, toX, y, protocol, signalStrength);
            }
          } else {
            // Draw broken connection
            ctx.strokeStyle = "#ef4444";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(fromX, y);
            ctx.lineTo(toX, y);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }

        function getProtocolColor(protocol) {
          const colors = {
            wifi: "#3b82f6",
            bluetooth: "#0ea5e9",
            lora: "#10b981",
            zigbee: "#f59e0b",
          };
          return colors[protocol] || "#94a3b8";
        }

        function getProtocolPattern(protocol) {
          const patterns = {
            wifi: [],
            bluetooth: [5, 5],
            lora: [10, 5],
            zigbee: [3, 3],
          };
          return patterns[protocol] || [];
        }

        function drawDataPackets(fromX, toX, y, protocol, strength) {
          const numPackets = Math.floor(strength * 8);
          const packetSize = 10;

          ctx.fillStyle = getProtocolColor(protocol);

          for (let i = 0; i < numPackets; i++) {
            const progress = (Date.now() / 1000 + i * 0.5) % 1;
            const x = fromX + (toX - fromX) * progress;

            ctx.fillRect(
              x - packetSize / 2,
              y - packetSize / 2,
              packetSize,
              packetSize
            );

            // Draw packet data
            ctx.fillStyle = "#fff";
            ctx.font = "8px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("DATA", x, y);
            ctx.fillStyle = getProtocolColor(protocol);
          }
        }

        protocolSelect.addEventListener("change", drawWirelessCommunication);
        distanceSlider.addEventListener("input", drawWirelessCommunication);
        powerSlider.addEventListener("input", drawWirelessCommunication);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["wireless-comm-lora-wifi"].resizeListener =
          resizeListener;

        resizeCanvas();
      }

      // 25. IoT Data Pipeline Simulation
      function initIotPipeline() {
        const canvas = document.getElementById("iot-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const sensorRateSlider = document.getElementById("sensor-rate");
        const processingSlider = document.getElementById("processing-speed");
        const storageSlider = document.getElementById("storage-capacity");
        const dataDisplay = document.getElementById("data-processed");
        const efficiencyDisplay = document.getElementById(
          "pipeline-efficiency"
        );

        let dataPoints = [];
        let totalData = 0;

        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.height;
          drawIoTPipeline();
        }

        function drawIoTPipeline() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const sensorRate = parseFloat(sensorRateSlider.value);
          const processingSpeed = parseFloat(processingSlider.value);
          const storageCapacity = parseFloat(storageSlider.value);

          const stageWidth = canvas.width / 5;
          const centerY = canvas.height / 2;

          // Draw pipeline stages
          drawPipelineStage(
            stageWidth * 1,
            centerY,
            "Sensors",
            "#3b82f6",
            sensorRate
          );
          drawPipelineStage(
            stageWidth * 2,
            centerY,
            "Gateway",
            "#f59e0b",
            processingSpeed
          );
          drawPipelineStage(
            stageWidth * 3,
            centerY,
            "Cloud",
            "#10b981",
            storageCapacity
          );
          drawPipelineStage(
            stageWidth * 4,
            centerY,
            "Dashboard",
            "#ef4444",
            100
          );

          // Draw data flow
          drawDataFlow(sensorRate, processingSpeed, storageCapacity);

          // Update data metrics
          totalData += sensorRate * 0.1;
          const efficiency = Math.min(
            100,
            (processingSpeed / sensorRate) * 100 * (storageCapacity / 100)
          );

          dataDisplay.textContent = Math.round(totalData);
          efficiencyDisplay.textContent = `${efficiency.toFixed(1)}%`;

          if (simulationInstances["iot-data-pipeline"].running) {
            simulationInstances["iot-data-pipeline"].animationFrameId =
              requestAnimationFrame(drawIoTPipeline);
          }
        }

        function drawPipelineStage(x, y, label, color, capacity) {
          // Draw stage container
          ctx.fillStyle = color + "40";
          ctx.fillRect(x - 40, y - 30, 80, 60);
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.strokeRect(x - 40, y - 30, 80, 60);

          // Draw capacity indicator
          ctx.fillStyle = color;
          const indicatorHeight = (capacity / 100) * 40;
          ctx.fillRect(x - 35, y + 20 - indicatorHeight, 70, indicatorHeight);

          // Draw label
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(label, x, y - 40);
          ctx.fillText(`${capacity}%`, x, y);

          // Draw stage icon
          drawStageIcon(x, y - 10, label, color);
        }

        function drawStageIcon(x, y, stage, color) {
          ctx.fillStyle = color;

          switch (stage) {
            case "Sensors":
              // Draw sensor icon
              ctx.beginPath();
              ctx.arc(x, y, 8, 0, Math.PI * 2);
              ctx.fill();
              break;
            case "Gateway":
              // Draw router icon
              ctx.fillRect(x - 10, y - 6, 20, 12);
              break;
            case "Cloud":
              // Draw cloud icon
              ctx.beginPath();
              ctx.arc(x - 5, y, 6, 0, Math.PI * 2);
              ctx.arc(x + 5, y, 8, 0, Math.PI * 2);
              ctx.fill();
              break;
            case "Dashboard":
              // Draw screen icon
              ctx.fillRect(x - 12, y - 8, 24, 16);
              break;
          }
        }

        function drawDataFlow(sensorRate, processingSpeed, storageCapacity) {
          const dataIntensity = sensorRate / 100;

          // Draw data particles between stages
          const now = Date.now();
          const stages = [
            { x: canvas.width / 5, enabled: true },
            {
              x: (2 * canvas.width) / 5,
              enabled: processingSpeed >= sensorRate * 0.8,
            },
            { x: (3 * canvas.width) / 5, enabled: storageCapacity >= 50 },
            { x: (4 * canvas.width) / 5, enabled: true },
          ];

          for (let i = 0; i < stages.length - 1; i++) {
            if (stages[i].enabled && stages[i + 1].enabled) {
              drawDataStream(
                stages[i].x + 40,
                stages[i + 1].x - 40,
                canvas.height / 2,
                dataIntensity
              );
            } else {
              // Draw blocked connection
              ctx.strokeStyle = "#ef4444";
              ctx.lineWidth = 2;
              ctx.setLineDash([5, 5]);
              ctx.beginPath();
              ctx.moveTo(stages[i].x + 40, canvas.height / 2);
              ctx.lineTo(stages[i + 1].x - 40, canvas.height / 2);
              ctx.stroke();
              ctx.setLineDash([]);
            }
          }
        }

        function drawDataStream(fromX, toX, y, intensity) {
          const numParticles = Math.floor(intensity * 20);

          ctx.strokeStyle = "rgba(59, 130, 246, 0.5)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(fromX, y);
          ctx.lineTo(toX, y);
          ctx.stroke();

          // Draw moving data particles
          for (let i = 0; i < numParticles; i++) {
            const progress = (now / 1000 + i * 0.2) % 1;
            const x = fromX + (toX - fromX) * progress;

            ctx.fillStyle = "#3b82f6";
            ctx.beginPath();
            ctx.arc(
              x,
              y + Math.sin(progress * Math.PI * 4) * 10,
              4,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }

        function startPipeline() {
          simulationInstances["iot-data-pipeline"].running = true;
          drawIoTPipeline();
        }

        function stopPipeline() {
          simulationInstances["iot-data-pipeline"].running = false;
          if (simulationInstances["iot-data-pipeline"].animationFrameId) {
            cancelAnimationFrame(
              simulationInstances["iot-data-pipeline"].animationFrameId
            );
          }
        }

        sensorRateSlider.addEventListener("input", drawIoTPipeline);
        processingSlider.addEventListener("input", drawIoTPipeline);
        storageSlider.addEventListener("input", drawIoTPipeline);

        document
          .getElementById("start-pipeline")
          ?.addEventListener("click", startPipeline);
        document
          .getElementById("stop-pipeline")
          ?.addEventListener("click", stopPipeline);

        const resizeListener = () => resizeCanvas();
        window.addEventListener("resize", resizeListener);
        simulationInstances["iot-data-pipeline"].resizeListener =
          resizeListener;

        resizeCanvas();
      }
    </script>
  </body>
</html>
